<!DOCTYPE html>
<html lang="zh">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kafka 日志模块（一）Log · 技术分享</title>
  <meta name="author" content="Siran Yao(姚毅晨)" />

  
  <meta name="keywords" content="Kafka">
  

  <meta name="generator" content="Hugo 0.65.2" />

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
  <link href="/css/style.default.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/search.css" />

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/1587537069710-removebg-preview.png" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/1587537069710-removebg-preview.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">
  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="拳拳到肉">

  
  <link rel="stylesheet" href="/css/prism.css" />

  
  <meta property="og:title" content="Kafka 日志模块（一）Log" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%B8%80log//" />
  <meta property="og:image" content="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" />
  <meta property="og:image:alt" content="ServiceMesher Logo" />

  
  <meta name="description" content="Kafka 使用`日志文件`的方式保存生产者发送的消息。每条消息都有一个 `offset` 值来标识它在分区中的偏移量，这个offset 是`逻辑值`，并不是消息实际存放的物理地址。">
  <meta property="og:description" content="Kafka 使用`日志文件`的方式保存生产者发送的消息。每条消息都有一个 `offset` 值来标识它在分区中的偏移量，这个offset 是`逻辑值`，并不是消息实际存放的物理地址。">
  <meta name="twitter:description" content="Kafka 使用`日志文件`的方式保存生产者发送的消息。每条消息都有一个 `offset` 值来标识它在分区中的偏移量，这个offset 是`逻辑值`，并不是消息实际存放的物理地址。">
  <meta property="og:description" content="Kafka 使用`日志文件`的方式保存生产者发送的消息。每条消息都有一个 `offset` 值来标识它在分区中的偏移量，这个offset 是`逻辑值`，并不是消息实际存放的物理地址。" />

  
  <meta name="referrer" content="never">

  
  
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?154337f0d95f0b110f98c1d5d7038895";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>


  
  

</head>


  <body>



    <div id="all">

        <header>

          <div class="navbar-affixed-top" data-spy="affix" data-offset-top="200">

    <div class="navbar navbar-default yamm" role="navigation" id="navbar">

        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="Kafka 日志模块（一）Log logo" class="hidden-xs hidden-sm">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="Kafka 日志模块（一）Log logo" class="visible-xs visible-sm">
                    <span class="sr-only">Kafka 日志模块（一）Log - 跳到主页</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only">切换导航</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="Kafka 日志模块（一）Log logo" class="hidden-xs hidden-sm">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="Kafka 日志模块（一）Log logo" class="visible-xs visible-sm">
                    <span class="sr-only">Kafka 日志模块（一）Log - 跳到主页</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                        <span class="sr-only">切换导航</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="Kafka 日志模块（一）Log logo" class="hidden-xs hidden-sm">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="Kafka 日志模块（一）Log logo" class="visible-xs visible-sm">
                    <span class="sr-only">Kafka 日志模块（一）Log - 跳到主页</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                        <span class="sr-only">切换导航</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">文档 <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        <li><a href="https://www.elastic.co/">Elastic 官网</a></li>
                      
                        <li><a href="http://pulsar.apache.org/en/">Pulsar官网</a></li>
                      
                    </ul>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">联系我</a>
                    
                  </li>
                  
                  
                    <li>
                        <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
                        <span class="hidden-sm hidden-md hidden-lg">搜索</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
                    </a>
                    </li>
                  
                </ul>
            </div>
            

        </div>
    </div>
    

</div>




<div id="modalSearch" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">博客搜索</h4>
      </div>
      <div class="modal-body">
          
<div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="输入文章标题或摘要" name="search" autocomplete="off" autofocus="autofocus"/>
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>

<script>
var client = algoliasearch("X4YB3WOBNV", "d2134c5a8d250e6d3246594240c45201");
var index = client.initIndex("servicemesher");

autocomplete('#aa-search-input',
{ hint: false}, {
    source: autocomplete.sources.hits(index, {hitsPerPage: 5}),
    
    displayKey: 'name',
    
    templates: {
        
        suggestion: function(suggestion) {
            baseURL=""
            baseURL=baseURL.substring(0,baseURL.length-1)
            return '<span>' + '<a href="' + baseURL + suggestion.url+ '">' +
                suggestion._highlightResult.title.value + '</a></span>'+
                '<span>'+suggestion._highlightResult.summary.value+'</span>';
        }
    }
});
</script>

      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
      </div>
    </div>
  </div>
</div>


        </header>

        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Kafka 日志模块（一）Log</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">
                        <div class="well">
                            <div class="author-category">
                            <i class="fa fa-calendar-o">
                            2020年5月1日
                            </i>
                            |
                            
                            作者 Siran
                            
                            
                            
                            |
                            15200字 | 阅读大约需要31分钟
                            </div>
                            
                            
                            <div class="author-category">
                            
                            
                            归档于 <a href="/categories/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97">消息队列</a>
                            
                            |
                            
                            
                            
                            标签
                            
                            <a style="text-transform:capitalize" href="/tags/kafka/"><i>#kafka</i></a>
                            
                            </div>
                            
                            
                        </div>
                        <div id="post-content">
                          <h3 id="1-概述">1. 概述</h3>
<p>Kafka 使用<code>日志文件</code>的方式保存生产者发送的消息。每条消息都有一个 <code>offset</code> 值来标识它在分区中的偏移量，这个offset 是<code>逻辑值</code>，并不是消息实际存放的物理地址。</p>
<ul>
<li><code>offset</code> 值类似与数据库表中的主键，主键唯一确定了数据库表中的一条记录</li>
<li><code>offset</code> 唯一确定了分区的一条消息。</li>
</ul>
<p><strong>如下图所示：</strong></p>
<p><img src="https://kafka.apache.org/25/images/log_anatomy.png" alt=""></p>
<ul>
<li>
<p><code>Topic</code>：Kafka 消息以 <code>Topic</code> 为基本单位进行归类，各个主题在逻辑上相互独立。</p>
</li>
<li>
<p><code>Partition</code>：每个主题有可以分为一个或者多个 <code>partition</code> ，可以在创建主题的时候指定，也可以之后修改</p>
</li>
<li>
<p><code>Offset</code>：每条消息在发送的时候会根据分区规则被追加到指定的分区中，分区中的每条消息都会被分配一个唯一的序列号</p>
</li>
</ul>
<p>Kafka 为了避免存储的日志文件太大，并不是直接对应磁盘上的一个日志文件，而是对应磁盘上的一个目录，如下图所示：</p>
<p><img src="http://img.sirann.cn//siran/20200501214502.png" alt=""></p>
<ul>
<li>通过 <code>topic_name</code> - <code>partition_id</code> 来命名，则对应topic 和对应的partition 的log的存储在此目录下的文件中。</li>
</ul>
<p>Kafka 还引入了 <code>LogSegment</code> 的概念，把Log分隔成多个分段也就是多个 LogSegment，如下如所示：
<img src="http://img.sirann.cn//siran/20200501215340.png" alt=""></p>
<ul>
<li>
<p><code>.log(日志文件)</code></p>
</li>
<li>
<p><code>.index(偏移量索引文件)</code></p>
</li>
<li>
<p><code>.timeindex(时间戳索引文件)</code></p>
</li>
<li>
<p>其他文件</p>
</li>
<li>
<p><code>activeSegment</code>：向Log 中追加消息时是顺序写入的，只有最后一个LogSegment 才能执行写入操作，之前的都不行。最后一个LogSegment 称之为<code>ActiveSegment</code>即表示活跃的日志分段，</p>
<ul>
<li>当activeSegment满足一定的条件时，就需要创建新的activeSegment，之后追加的消息将写入新的activeSegment</li>
</ul>
</li>
<li>
<p>每个 <code>LogSegment</code> 都有一个基准偏移量 <code>baseOffset</code>，用来表示当前 <code>LogSegment</code>中第一条消息的offset。偏移量是一个64位的长整型数，日志文件和两个索引文件都是根据基准偏移量（baseOffset）命名的，名称固定为20位数字，没有达到的位数则用0填充。比如第一个LogSegment的基准偏移量为0，对应的日志文件为 00000000000000000000.log。</p>
</li>
</ul>
<p>在 <a href="http://www.sirann.cn/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%89kafka-server-start.sh/">Kafka 服务端（三）kafka-server-start.sh</a> 一文中讲述了我们启动Kafka之后，Kafka 每个模块初始化的入口类。</p>
<p><code>Kafka</code> 的所有的消息都是通过<code>日志</code>来存储的，它是通过 <code>LogManager</code> 来进行初始化的，<code>Log</code> 类是真正操作日志的，LogManager 是用来管理 Log 的。</p>
<p>在LogManager 初始化的时候会通过 <code>log.dirs</code> 配置的位置来生成我们的Log，并且会生成5个文件，如下图：</p>
<p><img src="http://img.sirann.cn//siran/20200501162933.png" alt=""></p>
<ul>
<li>
<p><code>cleaner-offset-checkPoint</code>：清理检查点文件，用来记录每个主题的每个分区中已清理的偏移量</p>
</li>
<li>
<p><code>log-start-offset-checkpoint</code>：它用来标识日志的起始偏移量。各个副本在变动 <code>LEO</code> 和 <code>HW</code> 的过程中，<code>logStartOffset</code> 也有可能随之而动，Kafka 也有一个定时任务来负责将所有分区的logStartOffset书写到起始点文件log-start-offset-checkpoint中，定时周期由broker端参数<code>log.flush.start.offset.checkpoint.interval.ms</code>来配置，默认值为 <code>60000</code> 。</p>
</li>
<li>
<p><code>meta.properties</code>：记录一些元数据</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">cluster<span style="color:#f92672">.</span><span style="color:#a6e22e">id</span><span style="color:#f92672">=</span>7YpDHjejRY2QU_U5Wk_CDQ 
version<span style="color:#f92672">=</span>0
broker<span style="color:#f92672">.</span><span style="color:#a6e22e">id</span><span style="color:#f92672">=</span>0
</code></pre></div></li>
<li>
<p><code>recovery-point-offset-checkpoint</code>：Kafka 中会有一个定时任务负责将所有分区的 LEO 刷写到恢复点文件 recovery-point-offset-checkpoint 中，定时周期由 broker 端参数<code>log.flush.offset.checkpoint.interval.ms</code>来配置，默认值为 <code>60000</code></p>
</li>
<li>
<p><code>replication-offset-checkpoint</code>：定时任务负责将所有分区的 <code>HW</code> 刷写到复制点文件replication-offset-checkpoint中，定时周期由broker端参数<code>replica.high.watermark.checkpoint.interval.ms</code>来配置，默认值为5000</p>
</li>
</ul>
<p>这些定时任务在 []() 文中进行分析。这篇文章主要来分析 Kafka 是如何操作日志的。</p>
<hr>
<h3 id="2-源码解析">2. 源码解析</h3>
<p><strong>Log 类结构如下图：</strong>
<img src="http://img.sirann.cn//siran/20200501163248.png" alt=""></p>
<ul>
<li><code>LogAppendInfo</code>：一组待写入消息的各种信息。</li>
<li><code>Log</code>：核心类，对日志进行一些操作比如添加</li>
<li><code>RollParams</code>：用于日志是否切分</li>
<li><code>LogOffsetSnapshot</code>：分区内所有位移元数据的容器类</li>
<li><code>LogMetricNames</code>：Log的监控指标</li>
<li><code>LogReadInfo</code>：读取日志返回的数据及其元数据</li>
<li><code>CompletedTxn</code>：记录已完成事务的元数据，主要用于构建事务</li>
</ul>
<hr>
<h4 id="21-logappendinfo">2.1 LogAppendInfo</h4>
<p>保存了一组待写入消息的各种信息，比如这组消息中最后一条消息的offset，最大的时间戳是什么等信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogAppendInfo</span><span style="color:#f92672">(</span>var firstOffset<span style="color:#f92672">:</span> Option<span style="color:#f92672">[</span>Long<span style="color:#f92672">],</span>
                         var lastOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>  <span style="color:#75715e">// 消息集合最后一条消息的位移值
</span><span style="color:#75715e"></span>                         var maxTimestamp<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>  <span style="color:#75715e">// 消息集合最大消息时间戳
</span><span style="color:#75715e"></span>                         var offsetOfMaxTimestamp<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span> <span style="color:#75715e">// 消息集合最大消息时间戳所属消息的位移值
</span><span style="color:#75715e"></span>                         var logAppendTime<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span> <span style="color:#75715e">// 写入消息时间戳
</span><span style="color:#75715e"></span>                         var logStartOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span> 
                         var recordConversionStats<span style="color:#f92672">:</span> RecordConversionStats<span style="color:#f92672">,</span>  <span style="color:#75715e">// 消息转换统计类，里面记录了执行了格式转换的消息数等数据
</span><span style="color:#75715e"></span>                         sourceCodec<span style="color:#f92672">:</span> CompressionCodec<span style="color:#f92672">,</span> <span style="color:#75715e">// 消息集合中消息使用的压缩器（Compressor）类型，比如是Snappy还是LZ4
</span><span style="color:#75715e"></span>                         targetCodec<span style="color:#f92672">:</span> CompressionCodec<span style="color:#f92672">,</span> <span style="color:#75715e">// 写入消息时需要使用的压缩器类型
</span><span style="color:#75715e"></span>                         shallowCount<span style="color:#f92672">:</span> Int<span style="color:#f92672">,</span> <span style="color:#75715e">// 消息批次数，每个消息批次下可能包含多条消息
</span><span style="color:#75715e"></span>                         validBytes<span style="color:#f92672">:</span> Int<span style="color:#f92672">,</span> <span style="color:#75715e">// 写入消息总字节数
</span><span style="color:#75715e"></span>                         offsetsMonotonic<span style="color:#f92672">:</span> Boolean<span style="color:#f92672">,</span> <span style="color:#75715e">// 消息位移值是否是顺序增加的
</span><span style="color:#75715e"></span>                         lastOffsetOfFirstBatch<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span> <span style="color:#75715e">// 首个消息批次中最后一条消息的位移
</span><span style="color:#75715e"></span>                         recordErrors<span style="color:#f92672">:</span> Seq<span style="color:#f92672">[</span>RecordError<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> List<span style="color:#f92672">(),</span> <span style="color:#75715e">// 写入消息时出现的异常列表
</span><span style="color:#75715e"></span>                         errorMessage<span style="color:#f92672">:</span> String <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 错误码
</span><span style="color:#75715e"></span>  def firstOrLastOffsetOfFirstBatch<span style="color:#f92672">:</span> Long <span style="color:#f92672">=</span> firstOffset<span style="color:#f92672">.</span><span style="color:#a6e22e">getOrElse</span><span style="color:#f92672">(</span>lastOffsetOfFirstBatch<span style="color:#f92672">)</span>

  def numMessages<span style="color:#f92672">:</span> Long <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    firstOffset match <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">case</span> Some<span style="color:#f92672">(</span>firstOffsetVal<span style="color:#f92672">)</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>firstOffsetVal <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> lastOffset <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span>lastOffset <span style="color:#f92672">-</span> firstOffsetVal <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">case</span> _ <span style="color:#f92672">=&gt;</span> 0
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li><code>firstOffset</code>：消息集合中第一条消息的位移值</li>
<li><code>lastOffset</code>：消息集合最后一条消息的位移值</li>
<li><code>maxTimestamp</code>：消息集合最大消息时间戳</li>
<li><code>offsetOfMaxTimestamp</code>：消息集合最大消息时间戳所属消息的位移值</li>
<li><code>logAppendTime</code>：写入消息时间戳</li>
<li><code>logStartOffset</code>：日志文件的起始偏移量等于第一个日志分段的 baseOffset，但这并不是绝对的，logStartOffset 的值可以通过 DeleteRecordsRequest 请求（比如使用KafkaAdminClient的deleteRecords（）方法、使用kafka-delete-records.sh脚本）、日志的清理和截断等操作进行修改。</li>
<li><code>recordConversionStats</code>：消息转换统计类，里面记录了执行了格式转换的消息数等数据</li>
<li><code>sourceCodec</code>：消息集合中消息使用的压缩器（Compressor）类型，比如是Snappy还是LZ4</li>
<li><code>targetCodec</code>：写入消息时需要使用的压缩器类型</li>
<li><code>shallowCount</code>：消息批次数，每个消息批次下可能包含多条消息</li>
<li><code>validBytes</code>：写入消息总字节数</li>
<li><code>offsetsMonotonic</code>：消息位移值是否是顺序增加的</li>
<li><code>lastOffsetOfFirstBatch</code>：首个消息批次中最后一条消息的位移</li>
<li><code>recordErrors</code>：写入消息时出现的异常列表</li>
<li><code>errorMessage</code>：错误码</li>
</ul>
<hr>
<h4 id="22-rollparams">2.2 RollParams</h4>
<p>定义用于控制日志是否要切分的数据结构</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RollParams</span><span style="color:#f92672">(</span>maxSegmentMs<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
                      maxSegmentBytes<span style="color:#f92672">:</span> Int<span style="color:#f92672">,</span>
                      maxTimestampInMessages<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
                      maxOffsetInMessages<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
                      messagesSize<span style="color:#f92672">:</span> Int<span style="color:#f92672">,</span>
                      now<span style="color:#f92672">:</span> Long<span style="color:#f92672">)</span>
</code></pre></div><ul>
<li><code>maxSegmentMs</code>：这个 <code>Segment</code> 持续多久，当到了这个时间如果这个 <code>Segment</code> 文件没有满，那么会强制创建新的 <code>Segment</code> ，确保可以删除或者压缩日志。</li>
<li><code>maxSegmentBytes</code>：当前 <code>Segment</code> 能存储最大的字节数</li>
<li><code>maxTimestampInMessages</code>：当前 <code>Segment</code> 中最大的时间戳</li>
<li><code>maxOffsetInMessages</code>：当前 <code>Segment</code> 中最大的位移量</li>
<li><code>messagesSize</code>：当前 <code>Segment</code> 中消息的数量</li>
<li><code>now</code>：切分 <code>Segment</code> 的时间</li>
</ul>
<hr>
<h4 id="23-logreadinfo">2.3 LogReadInfo</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogReadInfo</span><span style="color:#f92672">(</span>fetchedData<span style="color:#f92672">:</span> FetchDataInfo<span style="color:#f92672">,</span>
                       highWatermark<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
                       logStartOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
                       logEndOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
                       lastStableOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">)</span>

</code></pre></div><hr>
<h4 id="24-logoffsetsnapshot">2.4 LogOffsetSnapshot</h4>
<p>分区内所有位移元数据的容器类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogOffsetSnapshot</span><span style="color:#f92672">(</span>logStartOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
                             logEndOffset<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">,</span>
                             highWatermark<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">,</span>
                             lastStableOffset<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">)</span>
</code></pre></div><ul>
<li><code>logStartOffset</code>：日志文件的起始偏移量等于第一个日志分段的 <code>baseOffset</code>，但这并不是绝对的，logStartOffset 的值可以通过 DeleteRecordsRequest 请求（比如使用KafkaAdminClient的deleteRecords（）方法、使用kafka-delete-records.sh脚本）、日志的清理和截断等操作进行修改。</li>
<li><code>logEndOffset</code>：下一条插入日志的的位移值</li>
<li><code>highWatermark</code>：高水位，消费者只能消费 <code>&lt;=</code> 此值的消息，当一条消息发送给Server 端，只有当所有的 <code>Replica</code> 同步后才会增加此值</li>
<li><code>lastStableOffset</code>：这个值和高水位一个意思，但是这个值只有在开启事务才有用，也就是说当开启事务后，消费者只能消费 <code>&lt;=</code> lastStableOffset 的消息。它不会超过 HW</li>
</ul>
<hr>
<h4 id="25-logmetricnames">2.5 LogMetricNames</h4>
<p>Log的监控指标</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">object LogMetricNames <span style="color:#f92672">{</span>
  val NumLogSegments<span style="color:#f92672">:</span> String <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;NumLogSegments&#34;</span>
  val LogStartOffset<span style="color:#f92672">:</span> String <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;LogStartOffset&#34;</span>
  val LogEndOffset<span style="color:#f92672">:</span> String <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;LogEndOffset&#34;</span>
  val Size<span style="color:#f92672">:</span> String <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Size&#34;</span>
<span style="color:#f92672">}</span>
</code></pre></div><hr>
<h4 id="26-completedtxn">2.6 CompletedTxn</h4>
<p>记录已完成事务的元数据，主要用于构建事务</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CompletedTxn</span><span style="color:#f92672">(</span>producerId<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span> firstOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span> lastOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span> isAborted<span style="color:#f92672">:</span> Boolean<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  override def toString<span style="color:#f92672">:</span> String <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#e6db74">&#34;CompletedTxn(&#34;</span> <span style="color:#f92672">+</span>
      s<span style="color:#e6db74">&#34;producerId=$producerId, &#34;</span> <span style="color:#f92672">+</span>
      s<span style="color:#e6db74">&#34;firstOffset=$firstOffset, &#34;</span> <span style="color:#f92672">+</span>
      s<span style="color:#e6db74">&#34;lastOffset=$lastOffset, &#34;</span> <span style="color:#f92672">+</span>
      s<span style="color:#e6db74">&#34;isAborted=$isAborted)&#34;</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><hr>
<h4 id="27-log">2.7 Log</h4>
<p>核心类，对日志进行一些操作比如 添加，Log 是对多个 <code>LogSegment</code> 对象顺序的组合，形成一个逻辑的日志，使用<code>跳表</code>来对 LogSegment 进行管理。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Log</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@volatile</span> var dir<span style="color:#f92672">:</span> File<span style="color:#f92672">,</span> <span style="color:#75715e">// dir 就是这个日志所在的文件夹路径，也就是主题分区的路径
</span><span style="color:#75715e"></span>          <span style="color:#a6e22e">@volatile</span> var config<span style="color:#f92672">:</span> LogConfig<span style="color:#f92672">,</span>
          <span style="color:#a6e22e">@volatile</span> var logStartOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span> <span style="color:#75715e">//日志的当前最早位移
</span><span style="color:#75715e"></span>          <span style="color:#a6e22e">@volatile</span> var recoveryPoint<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
          scheduler<span style="color:#f92672">:</span> Scheduler<span style="color:#f92672">,</span>
          brokerTopicStats<span style="color:#f92672">:</span> BrokerTopicStats<span style="color:#f92672">,</span>
          val time<span style="color:#f92672">:</span> Time<span style="color:#f92672">,</span>
          val maxProducerIdExpirationMs<span style="color:#f92672">:</span> Int<span style="color:#f92672">,</span>
          val producerIdExpirationCheckIntervalMs<span style="color:#f92672">:</span> Int<span style="color:#f92672">,</span>
          val topicPartition<span style="color:#f92672">:</span> TopicPartition<span style="color:#f92672">,</span>
          val producerStateManager<span style="color:#f92672">:</span> ProducerStateManager<span style="color:#f92672">,</span>
          logDirFailureChannel<span style="color:#f92672">:</span> LogDirFailureChannel<span style="color:#f92672">)</span> <span style="color:#66d9ef">extends</span> Logging with KafkaMetricsGroup<span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> val lastFlushedTime <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicLong<span style="color:#f92672">(</span>time<span style="color:#f92672">.</span><span style="color:#a6e22e">milliseconds</span><span style="color:#f92672">)</span>
  <span style="color:#a6e22e">@volatile</span> <span style="color:#66d9ef">private</span> var nextOffsetMetadata<span style="color:#f92672">:</span> LogOffsetMetadata <span style="color:#f92672">=</span> _
  <span style="color:#a6e22e">@volatile</span> <span style="color:#66d9ef">private</span> var highWatermarkMetadata<span style="color:#f92672">:</span> LogOffsetMetadata <span style="color:#f92672">=</span> LogOffsetMetadata<span style="color:#f92672">(</span>logStartOffset<span style="color:#f92672">)</span>
  <span style="color:#66d9ef">private</span> val segments<span style="color:#f92672">:</span> ConcurrentNavigableMap<span style="color:#f92672">[</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">lang</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Long</span><span style="color:#f92672">,</span> LogSegment<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentSkipListMap<span style="color:#f92672">[</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">lang</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Long</span><span style="color:#f92672">,</span> LogSegment<span style="color:#f92672">]</span>
  <span style="color:#a6e22e">@volatile</span> var leaderEpochCache<span style="color:#f92672">:</span> Option<span style="color:#f92672">[</span>LeaderEpochFileCache<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> None

<span style="color:#f92672">}</span>
      
</code></pre></div><ul>
<li><code>dir</code> ：日志所在的文件夹路径，也就是主题分区的路径</li>
<li><code>config</code> ：配置</li>
<li><code>logStartOffset</code> ：当前日志最早的位移值</li>
<li><code>recoveryPoint</code> ：日志的恢复点</li>
<li><code>scheduler</code> ：定时器</li>
<li><code>brokerTopicStats</code>：broker中topic的状态</li>
<li><code>maxProducerIdExpirationMs</code>：在ProducerId 被视为过期之后最长等待时间</li>
<li><code>producerIdExpirationCheckIntervalMs</code>：检查 Producer Id 是否过期的间隔时间</li>
<li><code>topicPartition</code>：topic - partition 的映射关系</li>
<li><code>producerStateManager</code>：</li>
<li><code>logDirFailureChannel</code>：日志失败的channel</li>
<li><code>lastFlushedTime</code>：最后一次flush的时间</li>
<li><code>nextOffsetMetadata</code>：下一个offset的一些元数据</li>
<li><code>highWatermarkMetadata</code>：hw的元数据</li>
<li><code>segments</code>：日志分段通过跳表来存储</li>
<li><code>leaderEpochCache</code>：leader epoch 的缓存，用于一致性。</li>
</ul>
<hr>
<h4 id="271-locally">2.7.1 locally</h4>
<p>Log 类的初始化方法</p>
<p><strong>流程图如下：</strong>
<img src="http://img.sirann.cn//siran/20200502133635.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">locally <span style="color:#f92672">{</span>
    val startMs <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span><span style="color:#a6e22e">milliseconds</span>

    <span style="color:#75715e">// create the log directory if it doesn&#39;t exist
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//① 创建log文件，如果不存在就创建。通过dir属性
</span><span style="color:#75715e"></span>    Files<span style="color:#f92672">.</span><span style="color:#a6e22e">createDirectories</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>

    <span style="color:#75715e">//② 初始化 Leader Epoch Cache
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//创建Leader Epoch 检查点文件
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//生成Leader Epoch Cache 对象
</span><span style="color:#75715e"></span>    initializeLeaderEpochCache<span style="color:#f92672">()</span>

    <span style="color:#75715e">//③ 加载所有日志分段
</span><span style="color:#75715e"></span>    val nextOffset <span style="color:#f92672">=</span> loadSegments<span style="color:#f92672">()</span>

    <span style="color:#75715e">/* Calculate the offset of the next message */</span>
    <span style="color:#75715e">//④ 更新nextOffsetMetadata 和 logStartOffset
</span><span style="color:#75715e"></span>    nextOffsetMetadata <span style="color:#f92672">=</span> LogOffsetMetadata<span style="color:#f92672">(</span>nextOffset<span style="color:#f92672">,</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">,</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">)</span>

    leaderEpochCache<span style="color:#f92672">.</span><span style="color:#a6e22e">foreach</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">truncateFromEnd</span><span style="color:#f92672">(</span>nextOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span><span style="color:#f92672">))</span>

    updateLogStartOffset<span style="color:#f92672">(</span>math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>logStartOffset<span style="color:#f92672">,</span> segments<span style="color:#f92672">.</span><span style="color:#a6e22e">firstEntry</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">))</span>

    <span style="color:#75715e">// The earliest leader epoch may not be flushed during a hard failure. Recover it here.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//⑤ 更新Leader Epoch Cache ，清除无效处理
</span><span style="color:#75715e"></span>    leaderEpochCache<span style="color:#f92672">.</span><span style="color:#a6e22e">foreach</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">truncateFromStart</span><span style="color:#f92672">(</span>logStartOffset<span style="color:#f92672">))</span>

    <span style="color:#75715e">// Any segment loading or recovery code must not use producerStateManager, so that we can build the full state here
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// from scratch.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>producerStateManager<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Producer state must be empty during log initialization&#34;</span><span style="color:#f92672">)</span>
    loadProducerState<span style="color:#f92672">(</span>logEndOffset<span style="color:#f92672">,</span> reloadFromCleanShutdown <span style="color:#f92672">=</span> hasCleanShutdownFile<span style="color:#f92672">)</span>

    info<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Completed load of log with ${segments.size} segments, log start offset $logStartOffset and &#34;</span> <span style="color:#f92672">+</span>
      s<span style="color:#e6db74">&#34;log end offset $logEndOffset in ${time.milliseconds() - startMs} ms&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p>① <code>createDirectories( )</code>：创建 log 文件夹，如果不存在就创建。
<img src="http://img.sirann.cn//siran/20200501230554.png" alt=""></p>
</li>
<li>
<p>② <code>initializeLeaderEpochCache( )</code>：初始化 Leader Epoch Cache</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">initializeLeaderEpochCache</span><span style="color:#f92672">():</span> Unit <span style="color:#f92672">=</span> lock <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">//2.1 创建 leader-epoch-checkpoint 文件
</span><span style="color:#75715e"></span>  val leaderEpochFile <span style="color:#f92672">=</span> LeaderEpochCheckpointFile<span style="color:#f92672">.</span><span style="color:#a6e22e">newFile</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">)</span>

  def <span style="color:#a6e22e">newLeaderEpochFileCache</span><span style="color:#f92672">():</span> LeaderEpochFileCache <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    val checkpointFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LeaderEpochCheckpointFile<span style="color:#f92672">(</span>leaderEpochFile<span style="color:#f92672">,</span> logDirFailureChannel<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">new</span> LeaderEpochFileCache<span style="color:#f92672">(</span>topicPartition<span style="color:#f92672">,</span> logEndOffset _<span style="color:#f92672">,</span> checkpointFile<span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">//2.2 实例化 LeaderEpochFileCache 对象，此对象用来缓存 tp 和 leo的关系
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>recordVersion<span style="color:#f92672">.</span><span style="color:#a6e22e">precedes</span><span style="color:#f92672">(</span>RecordVersion<span style="color:#f92672">.</span><span style="color:#a6e22e">V2</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
    val currentCache <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>leaderEpochFile<span style="color:#f92672">.</span><span style="color:#a6e22e">exists</span><span style="color:#f92672">())</span>
      Some<span style="color:#f92672">(</span>newLeaderEpochFileCache<span style="color:#f92672">())</span>
    <span style="color:#66d9ef">else</span>
      None

    <span style="color:#a6e22e">if</span> <span style="color:#f92672">(</span>currentCache<span style="color:#f92672">.</span><span style="color:#a6e22e">exists</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">nonEmpty</span><span style="color:#f92672">))</span>
      warn<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Deleting non-empty leader epoch cache due to incompatible message format $recordVersion&#34;</span><span style="color:#f92672">)</span>

    Files<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteIfExists</span><span style="color:#f92672">(</span>leaderEpochFile<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>
    leaderEpochCache <span style="color:#f92672">=</span> None
  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
    leaderEpochCache <span style="color:#f92672">=</span> Some<span style="color:#f92672">(</span>newLeaderEpochFileCache<span style="color:#f92672">())</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>2.1 创建 <code>leader-epoch-checkpoint</code> 文件，此文件是用于记录每个当前Kafka Leader 的epoch，用于一致性。
<img src="http://img.sirann.cn//siran/20200502122912.png" alt=""></li>
<li>2.2 实例化 <code>LeaderEpochFileCache</code> 对象，此对象用来缓存 <code>tp</code> 和 <code>leo</code> 的关系</li>
</ul>
</li>
<li>
<p>③ <code>loadSegments( )</code>：加载所有日志分段</p>
</li>
<li>
<p>④ 更新 <code>nextOffsetMetadata</code> 和 <code>logStartOffset</code></p>
</li>
<li>
<p>⑤ 更新 Leader Epoch Cache ，清除无效处理</p>
</li>
</ul>
<h4 id="2711-loadsegments">2.7.1.1 loadSegments</h4>
<p>在 <code>Log</code> 类的初始化 <code>locally</code> 方法中的第 <code>③</code> 步 通过<code>loadSegments( )</code>方法加载当前所有的 <code>Segments</code> 。
大致逻辑：</p>
<ol>
<li>移除上次 <code>Failure</code> 遗留下来的各种临时文件（包括<code>.cleaned、.swap、.deleted</code> 文件等）</li>
<li>清空所有日志段对象，并且再次遍历分区路径，重建日志段 <code>segments Map</code> 以及索引文件。</li>
<li>待执行完这两次遍历之后，它会完成未完成的 swap 操作，即调用 <code>completeSwapOperations</code> 方法。</li>
<li>等这些都做完之后，再调用 <code>recoverLog</code> 方法恢复日志段对象，然后返回恢复之后的分区日志 LEO 值。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">loadSegments</span><span style="color:#f92672">():</span> Long <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//① 移除上次 Failure 遗留下来的各种临时文件（包括.cleaned、.swap、.deleted 文件等）
</span><span style="color:#75715e"></span>    val swapFiles <span style="color:#f92672">=</span> removeTempFilesAndCollectSwapFiles<span style="color:#f92672">()</span>

    retryOnOffsetOverflow <span style="color:#f92672">{</span>
      logSegments<span style="color:#f92672">.</span><span style="color:#a6e22e">foreach</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">())</span>
      segments<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">()</span>
      <span style="color:#75715e">//② 重新加载日志段文件
</span><span style="color:#75715e"></span>      loadSegmentFiles<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//③ 处理第①步返回的有效.swap 文件集合
</span><span style="color:#75715e"></span>    completeSwapOperations<span style="color:#f92672">(</span>swapFiles<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>dir<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">.</span><span style="color:#a6e22e">endsWith</span><span style="color:#f92672">(</span>Log<span style="color:#f92672">.</span><span style="color:#a6e22e">DeleteDirSuffix</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
      val nextOffset <span style="color:#f92672">=</span> retryOnOffsetOverflow <span style="color:#f92672">{</span>
        <span style="color:#75715e">//④ 恢复日志
</span><span style="color:#75715e"></span>        recoverLog<span style="color:#f92672">()</span>
      <span style="color:#f92672">}</span>

      activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">resizeIndexes</span><span style="color:#f92672">(</span>config<span style="color:#f92672">.</span><span style="color:#a6e22e">maxIndexSize</span><span style="color:#f92672">)</span>
      nextOffset
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
       <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>logSegments<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          addSegment<span style="color:#f92672">(</span>LogSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">(</span>dir <span style="color:#f92672">=</span> dir<span style="color:#f92672">,</span>
            baseOffset <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span>
            config<span style="color:#f92672">,</span>
            time <span style="color:#f92672">=</span> time<span style="color:#f92672">,</span>
            fileAlreadyExists <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span>
            initFileSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">initFileSize</span><span style="color:#f92672">,</span>
            preallocate <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">))</span>
       <span style="color:#f92672">}</span>
      0
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>① <code>removeTempFilesAndCollectSwapFiles( )</code>：移除上次 Failure 遗留下来的各种临时文件（包括.cleaned、.swap、.deleted 文件等）
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">removeTempFilesAndCollectSwapFiles</span><span style="color:#f92672">():</span> Set<span style="color:#f92672">[</span>File<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>

  <span style="color:#75715e">//在方法内部定义一个名为deleteIndicesIfExist的方法，用于删除日志文件对应的索引文件
</span><span style="color:#75715e"></span>  def <span style="color:#a6e22e">deleteIndicesIfExist</span><span style="color:#f92672">(</span>baseFile<span style="color:#f92672">:</span> File<span style="color:#f92672">,</span> suffix<span style="color:#f92672">:</span> String <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">):</span> Unit <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    info<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Deleting index files with suffix $suffix for baseFile $baseFile&#34;</span><span style="color:#f92672">)</span>
    val offset <span style="color:#f92672">=</span> offsetFromFile<span style="color:#f92672">(</span>baseFile<span style="color:#f92672">)</span>
    Files<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteIfExists</span><span style="color:#f92672">(</span>Log<span style="color:#f92672">.</span><span style="color:#a6e22e">offsetIndexFile</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> offset<span style="color:#f92672">,</span> suffix<span style="color:#f92672">).</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>
    Files<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteIfExists</span><span style="color:#f92672">(</span>Log<span style="color:#f92672">.</span><span style="color:#a6e22e">timeIndexFile</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> offset<span style="color:#f92672">,</span> suffix<span style="color:#f92672">).</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>
    Files<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteIfExists</span><span style="color:#f92672">(</span>Log<span style="color:#f92672">.</span><span style="color:#a6e22e">transactionIndexFile</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> offset<span style="color:#f92672">,</span> suffix<span style="color:#f92672">).</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>

  var swapFiles <span style="color:#f92672">=</span> Set<span style="color:#f92672">[</span>File<span style="color:#f92672">]()</span>
  var cleanFiles <span style="color:#f92672">=</span> Set<span style="color:#f92672">[</span>File<span style="color:#f92672">]()</span>
  var minCleanedFileOffset <span style="color:#f92672">=</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MaxValue</span>

  <span style="color:#75715e">//① 遍历分区日志路径下的所有文件
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>file <span style="color:#f92672">&lt;-</span> dir<span style="color:#f92672">.</span><span style="color:#a6e22e">listFiles</span> <span style="color:#66d9ef">if</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">isFile</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">canRead</span><span style="color:#f92672">)</span> <span style="color:#75715e">//如果不可读，直接抛出IOException
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IOException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Could not read file $file&#34;</span><span style="color:#f92672">)</span>
    val filename <span style="color:#f92672">=</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span>
    <span style="color:#75715e">//② 如果文件是以.deleted结尾，说明是上次Failure遗留下来的文件，直接删除
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>filename<span style="color:#f92672">.</span><span style="color:#a6e22e">endsWith</span><span style="color:#f92672">(</span>DeletedFileSuffix<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
      debug<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Deleting stray temporary file ${file.getAbsolutePath}&#34;</span><span style="color:#f92672">)</span>
      Files<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteIfExists</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span> 
    <span style="color:#75715e">//③ 如果是以.cleaned结尾
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>filename<span style="color:#f92672">.</span><span style="color:#a6e22e">endsWith</span><span style="color:#f92672">(</span>CleanedFileSuffix<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">//选取文件名中位移值最小的.cleaned文件，获取其位移值，并将该文件加入待删除文件集合中
</span><span style="color:#75715e"></span>      minCleanedFileOffset <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>offsetFromFileName<span style="color:#f92672">(</span>filename<span style="color:#f92672">),</span> minCleanedFileOffset<span style="color:#f92672">)</span>
      cleanFiles <span style="color:#f92672">+=</span> file
    <span style="color:#75715e">//④ 如果以.swap结尾 
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>filename<span style="color:#f92672">.</span><span style="color:#a6e22e">endsWith</span><span style="color:#f92672">(</span>SwapFileSuffix<span style="color:#f92672">))</span> <span style="color:#f92672">{</span> 
      <span style="color:#75715e">// we crashed in the middle of a swap operation, to recover:
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// if a log, delete the index files, complete the swap operation later
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// if an index just delete the index files, they will be rebuilt
</span><span style="color:#75715e"></span>      val baseFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>CoreUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">replaceSuffix</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">getPath</span><span style="color:#f92672">,</span> SwapFileSuffix<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">))</span>
      info<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Found file ${file.getAbsolutePath} from interrupted swap operation.&#34;</span><span style="color:#f92672">)</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isIndexFile<span style="color:#f92672">(</span>baseFile<span style="color:#f92672">))</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 如果该.swap文件原来是索引文件
</span><span style="color:#75715e"></span>        deleteIndicesIfExist<span style="color:#f92672">(</span>baseFile<span style="color:#f92672">)</span> <span style="color:#75715e">// 删除原来的索引文件
</span><span style="color:#75715e"></span>      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isLogFile<span style="color:#f92672">(</span>baseFile<span style="color:#f92672">))</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 如果该.swap文件原来是日志文件
</span><span style="color:#75715e"></span>        deleteIndicesIfExist<span style="color:#f92672">(</span>baseFile<span style="color:#f92672">)</span> <span style="color:#75715e">// 删除掉原来的索引文件
</span><span style="color:#75715e"></span>        swapFiles <span style="color:#f92672">+=</span> file <span style="color:#75715e">// 加入待恢复的.swap文件集合中
</span><span style="color:#75715e"></span>      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">// KAFKA-6264: Delete all .swap files whose base offset is greater than the minimum .cleaned segment offset. Such .swap
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// files could be part of an incomplete split operation that could not complete. See Log#splitOverflowedSegment
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// for more details about the split operation.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 从待恢复swap集合中找出那些起始位移值大于minCleanedFileOffset值的文件，直接删掉这些无效的.swap文件
</span><span style="color:#75715e"></span>  val <span style="color:#f92672">(</span>invalidSwapFiles<span style="color:#f92672">,</span> validSwapFiles<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> swapFiles<span style="color:#f92672">.</span><span style="color:#a6e22e">partition</span><span style="color:#f92672">(</span>file <span style="color:#f92672">=&gt;</span> offsetFromFile<span style="color:#f92672">(</span>file<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;=</span> minCleanedFileOffset<span style="color:#f92672">)</span>
  invalidSwapFiles<span style="color:#f92672">.</span><span style="color:#a6e22e">foreach</span> <span style="color:#f92672">{</span> file <span style="color:#f92672">=&gt;</span>
    debug<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Deleting invalid swap file ${file.getAbsoluteFile} minCleanedFileOffset: $minCleanedFileOffset&#34;</span><span style="color:#f92672">)</span>
    val baseFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>CoreUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">replaceSuffix</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">getPath</span><span style="color:#f92672">,</span> SwapFileSuffix<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">))</span>
    deleteIndicesIfExist<span style="color:#f92672">(</span>baseFile<span style="color:#f92672">,</span> SwapFileSuffix<span style="color:#f92672">)</span>
    Files<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteIfExists</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">// Now that we have deleted all .swap files that constitute an incomplete split operation, let&#39;s delete all .clean files
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//清除所有待删除文件集合中的文件
</span><span style="color:#75715e"></span>  cleanFiles<span style="color:#f92672">.</span><span style="color:#a6e22e">foreach</span> <span style="color:#f92672">{</span> file <span style="color:#f92672">=&gt;</span>
    debug<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Deleting stray .clean file ${file.getAbsolutePath}&#34;</span><span style="color:#f92672">)</span>
    Files<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteIfExists</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">//最后返回当前有效的.swap文件集合
</span><span style="color:#75715e"></span>  validSwapFiles
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>② <code>loadSegmentFiles( )</code> ：重新加载日志段文件
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">loadSegmentFiles</span><span style="color:#f92672">():</span> Unit <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">// load segments in ascending order because transactional data from one segment may depend on the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// segments that come before it
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//按照日志段文件名中的位移值正序排列，然后遍历每个文件
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>file <span style="color:#f92672">&lt;-</span> dir<span style="color:#f92672">.</span><span style="color:#a6e22e">listFiles</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sortBy</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">if</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">isFile</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isIndexFile<span style="color:#f92672">(</span>file<span style="color:#f92672">))</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 如果是索引文件
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// if it is an index file, make sure it has a corresponding .log file
</span><span style="color:#75715e"></span>      val offset <span style="color:#f92672">=</span> offsetFromFile<span style="color:#f92672">(</span>file<span style="color:#f92672">)</span>
      val logFile <span style="color:#f92672">=</span> Log<span style="color:#f92672">.</span><span style="color:#a6e22e">logFile</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> offset<span style="color:#f92672">)</span>
      <span style="color:#75715e">// 确保存在对应的日志文件，否则记录一个警告，并删除该索引文件
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>logFile<span style="color:#f92672">.</span><span style="color:#a6e22e">exists</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        warn<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Found an orphaned index file ${file.getAbsolutePath}, with no corresponding log file.&#34;</span><span style="color:#f92672">)</span>
        Files<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteIfExists</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>
      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isLogFile<span style="color:#f92672">(</span>file<span style="color:#f92672">))</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 如果是日志文件
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// if it&#39;s a log file, load the corresponding log segment
</span><span style="color:#75715e"></span>      val baseOffset <span style="color:#f92672">=</span> offsetFromFile<span style="color:#f92672">(</span>file<span style="color:#f92672">)</span>
      val timeIndexFileNewlyCreated <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>Log<span style="color:#f92672">.</span><span style="color:#a6e22e">timeIndexFile</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> baseOffset<span style="color:#f92672">).</span><span style="color:#a6e22e">exists</span><span style="color:#f92672">()</span>
      <span style="color:#75715e">// 创建对应的LogSegment对象实例，并加入segments中
</span><span style="color:#75715e"></span>      val segment <span style="color:#f92672">=</span> LogSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">(</span>dir <span style="color:#f92672">=</span> dir<span style="color:#f92672">,</span>
        baseOffset <span style="color:#f92672">=</span> baseOffset<span style="color:#f92672">,</span>
        config<span style="color:#f92672">,</span>
        time <span style="color:#f92672">=</span> time<span style="color:#f92672">,</span>
        fileAlreadyExists <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>

      <span style="color:#66d9ef">try</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">sanityCheck</span><span style="color:#f92672">(</span>timeIndexFileNewlyCreated<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">catch</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">case</span> _<span style="color:#f92672">:</span> NoSuchFileException <span style="color:#f92672">=&gt;</span>
          error<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Could not find offset index file corresponding to log file ${segment.log.file.getAbsolutePath}, &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;recovering segment and rebuilding index files...&#34;</span><span style="color:#f92672">)</span>
          recoverSegment<span style="color:#f92672">(</span>segment<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">case</span> e<span style="color:#f92672">:</span> CorruptIndexException <span style="color:#f92672">=&gt;</span>
          warn<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Found a corrupted index file corresponding to log file ${segment.log.file.getAbsolutePath} due &#34;</span> <span style="color:#f92672">+</span>
            s<span style="color:#e6db74">&#34;to ${e.getMessage}}, recovering segment and rebuilding index files...&#34;</span><span style="color:#f92672">)</span>
          recoverSegment<span style="color:#f92672">(</span>segment<span style="color:#f92672">)</span>
      <span style="color:#f92672">}</span>
      addSegment<span style="color:#f92672">(</span>segment<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>③ <code>completeSwapOperations( )</code> ：处理第①步返回的有效.swap 文件集合
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">completeSwapOperations</span><span style="color:#f92672">(</span>swapFiles<span style="color:#f92672">:</span> Set<span style="color:#f92672">[</span>File<span style="color:#f92672">]):</span> Unit <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">//① 遍历所有有效.swap文件
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>swapFile <span style="color:#f92672">&lt;-</span> swapFiles<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val logFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>CoreUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">replaceSuffix</span><span style="color:#f92672">(</span>swapFile<span style="color:#f92672">.</span><span style="color:#a6e22e">getPath</span><span style="color:#f92672">,</span> SwapFileSuffix<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">))</span>
    <span style="color:#75715e">//拿到日志文件的起始位移值
</span><span style="color:#75715e"></span>    val baseOffset <span style="color:#f92672">=</span> offsetFromFile<span style="color:#f92672">(</span>logFile<span style="color:#f92672">)</span>
    <span style="color:#75715e">//② 创建对应的LogSegment实例
</span><span style="color:#75715e"></span>    val swapSegment <span style="color:#f92672">=</span> LogSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">(</span>swapFile<span style="color:#f92672">.</span><span style="color:#a6e22e">getParentFile</span><span style="color:#f92672">,</span>
      baseOffset <span style="color:#f92672">=</span> baseOffset<span style="color:#f92672">,</span>
      config<span style="color:#f92672">,</span>
      time <span style="color:#f92672">=</span> time<span style="color:#f92672">,</span>
      fileSuffix <span style="color:#f92672">=</span> SwapFileSuffix<span style="color:#f92672">)</span>
    info<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Found log file ${swapFile.getPath} from interrupted swap operation, repairing.&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#75715e">//③ 执行日志段恢复操作
</span><span style="color:#75715e"></span>    recoverSegment<span style="color:#f92672">(</span>swapSegment<span style="color:#f92672">)</span>

    <span style="color:#75715e">// We create swap files for two cases:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// (1) Log cleaning where multiple segments are merged into one, and
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// (2) Log splitting where one segment is split into multiple.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Both of these mean that the resultant swap segments be composed of the original set, i.e. the swap segment
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// must fall within the range of existing segment(s). If we cannot find such a segment, it means the deletion
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// of that segment was successful. In such an event, we should simply rename the .swap to .log without having to
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// do a replace with an existing segment.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//④确认之前删除日志段是否成功，是否还存在老的日志段文件
</span><span style="color:#75715e"></span>    val oldSegments <span style="color:#f92672">=</span> logSegments<span style="color:#f92672">(</span>swapSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">,</span> swapSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">readNextOffset</span><span style="color:#f92672">).</span><span style="color:#a6e22e">filter</span> <span style="color:#f92672">{</span> segment <span style="color:#f92672">=&gt;</span>
      segment<span style="color:#f92672">.</span><span style="color:#a6e22e">readNextOffset</span> <span style="color:#f92672">&gt;</span> swapSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// ⑤ 如果存在，直接把.swap文件重命名成.log
</span><span style="color:#75715e"></span>    replaceSegments<span style="color:#f92672">(</span>Seq<span style="color:#f92672">(</span>swapSegment<span style="color:#f92672">),</span> oldSegments<span style="color:#f92672">.</span><span style="color:#a6e22e">toSeq</span><span style="color:#f92672">,</span> isRecoveredSwapFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>④ <code>recoverLog( )</code>：恢复日志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">recoverLog</span><span style="color:#f92672">():</span> Long <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">// if we have the clean shutdown marker, skip recovery
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//① 如果不存在以.kafka_cleanshutdown结尾的文件。通常都不存在
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>hasCleanShutdownFile<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// okay we need to actually recover this log
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//获取到上次恢复点以外的所有unflushed日志段对象
</span><span style="color:#75715e"></span>    val unflushed <span style="color:#f92672">=</span> logSegments<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">recoveryPoint</span><span style="color:#f92672">,</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MaxValue</span><span style="color:#f92672">).</span><span style="color:#a6e22e">toIterator</span>
    var truncated <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>

    <span style="color:#75715e">//遍历这些unflushed日志段
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>unflushed<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>truncated<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      val segment <span style="color:#f92672">=</span> unflushed<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span>
      <span style="color:#a6e22e">info</span><span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Recovering unflushed segment ${segment.baseOffset}&#34;</span><span style="color:#f92672">)</span>
      val truncatedBytes <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
          <span style="color:#75715e">//执行恢复日志段操作
</span><span style="color:#75715e"></span>          recoverSegment<span style="color:#f92672">(</span>segment<span style="color:#f92672">,</span> leaderEpochCache<span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">case</span> _<span style="color:#f92672">:</span> InvalidOffsetException <span style="color:#f92672">=&gt;</span>
            val startOffset <span style="color:#f92672">=</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span>
            <span style="color:#a6e22e">warn</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Found invalid offset during recovery. Deleting the corrupt segment and &#34;</span> <span style="color:#f92672">+</span>
              s<span style="color:#e6db74">&#34;creating an empty one with starting offset $startOffset&#34;</span><span style="color:#f92672">)</span>
            segment<span style="color:#f92672">.</span><span style="color:#a6e22e">truncateTo</span><span style="color:#f92672">(</span>startOffset<span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
      <span style="color:#75715e">// 如果有无效的消息导致被截断的字节数不为0，直接删除剩余的日志段对象
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>truncatedBytes <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// we had an invalid message, delete all remaining log
</span><span style="color:#75715e"></span>        warn<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Corruption found in segment ${segment.baseOffset}, truncating to offset ${segment.readNextOffset}&#34;</span><span style="color:#f92672">)</span>
        removeAndDeleteSegments<span style="color:#f92672">(</span>unflushed<span style="color:#f92672">.</span><span style="color:#a6e22e">toList</span><span style="color:#f92672">,</span> asyncDelete <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
        truncated <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">// 这些都做完之后，如果日志段集合不为空
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>logSegments<span style="color:#f92672">.</span><span style="color:#a6e22e">nonEmpty</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val logEndOffset <span style="color:#f92672">=</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">readNextOffset</span>
    <span style="color:#75715e">// 验证分区日志的LEO值不能小于Log Start Offset值，否则删除这些日志段对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>logEndOffset <span style="color:#f92672">&lt;</span> logStartOffset<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      warn<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Deleting all segments because logEndOffset ($logEndOffset) is smaller than logStartOffset ($logStartOffset). &#34;</span> <span style="color:#f92672">+</span>
        <span style="color:#e6db74">&#34;This could happen if segment files were deleted from the file system.&#34;</span><span style="color:#f92672">)</span>
      removeAndDeleteSegments<span style="color:#f92672">(</span>logSegments<span style="color:#f92672">,</span> asyncDelete <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">// 这些都做完之后，如果日志段集合为空了
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>logSegments<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// no existing segments, create a new mutable segment beginning at logStartOffset
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 至少创建一个新的日志段，以logStartOffset为日志段的起始位移，并加入日志段集合中
</span><span style="color:#75715e"></span>    addSegment<span style="color:#f92672">(</span>LogSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">(</span>dir <span style="color:#f92672">=</span> dir<span style="color:#f92672">,</span>
      baseOffset <span style="color:#f92672">=</span> logStartOffset<span style="color:#f92672">,</span>
      config<span style="color:#f92672">,</span>
      time <span style="color:#f92672">=</span> time<span style="color:#f92672">,</span>
      fileAlreadyExists <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span>
      initFileSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">initFileSize</span><span style="color:#f92672">,</span>
      preallocate <span style="color:#f92672">=</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">preallocate</span><span style="color:#f92672">))</span>
  <span style="color:#f92672">}</span>
  <span style="color:#75715e">// 更新上次恢复点属性，并返回
</span><span style="color:#75715e"></span>  recoveryPoint <span style="color:#f92672">=</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">readNextOffset</span>
  recoveryPoint
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li><code>recoverSegment</code>：循环恢复日志分段，在<a href="http://sirann.cn/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BA%8Clogsegment/">Kafka 日志模块（二）LogSegment</a>一文中进行分析。</li>
</ul>
<hr>
<blockquote>
<p>Log 初始化完成之后接下来就是对<code>Log</code>的一些操作，比如重要的就是 <strong>HW、LogSegment、日志位移、读写日志</strong>。</p>
</blockquote>
<h4 id="272-hw-高水位">2.7.2 HW 高水位</h4>
<p>高水位值的初始值是 <code>Log Start Offset</code> 值。每个 Log 对象都会维护一个 <code>Log Start Offset</code> 值。当首次构建高水位时，它会被赋值成 <code>Log Start Offset</code> 值。它是表示消费者只能看到 <code>&lt;= HW</code> 的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@volatile</span> <span style="color:#66d9ef">private</span> var highWatermarkMetadata<span style="color:#f92672">:</span> LogOffsetMetadata <span style="color:#f92672">=</span> LogOffsetMetadata<span style="color:#f92672">(</span>logStartOffset<span style="color:#f92672">)</span>
</code></pre></div><p>可以看到它是一个 <code>LogOffsetMetadata</code> 对象</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogOffsetMetadata</span><span style="color:#f92672">(</span>messageOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
                             segmentBaseOffset<span style="color:#f92672">:</span> Long <span style="color:#f92672">=</span> Log<span style="color:#f92672">.</span><span style="color:#a6e22e">UnknownOffset</span><span style="color:#f92672">,</span>
                             relativePositionInSegment<span style="color:#f92672">:</span> Int <span style="color:#f92672">=</span> LogOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">UnknownFilePosition</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

  def <span style="color:#a6e22e">onOlderSegment</span><span style="color:#f92672">(</span>that<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">):</span> Boolean <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>messageOffsetOnly<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> KafkaException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;$this cannot compare its segment info with $that since it only has message offset info&#34;</span><span style="color:#f92672">)</span>

    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">segmentBaseOffset</span> <span style="color:#f92672">&lt;</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">segmentBaseOffset</span>
  <span style="color:#f92672">}</span>

  def <span style="color:#a6e22e">onSameSegment</span><span style="color:#f92672">(</span>that<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">):</span> Boolean <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>messageOffsetOnly<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> KafkaException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;$this cannot compare its segment info with $that since it only has message offset info&#34;</span><span style="color:#f92672">)</span>

    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">segmentBaseOffset</span> <span style="color:#f92672">==</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">segmentBaseOffset</span>
  <span style="color:#f92672">}</span>

  def <span style="color:#a6e22e">offsetDiff</span><span style="color:#f92672">(</span>that<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">):</span> Long <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span> <span style="color:#f92672">-</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span>
  <span style="color:#f92672">}</span>

  def <span style="color:#a6e22e">positionDiff</span><span style="color:#f92672">(</span>that<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">):</span> Int <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(!</span>onSameSegment<span style="color:#f92672">(</span>that<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> KafkaException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;$this cannot compare its segment position with $that since they are not on the same segment&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>messageOffsetOnly<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> KafkaException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;$this cannot compare its segment position with $that since it only has message offset info&#34;</span><span style="color:#f92672">)</span>

    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">relativePositionInSegment</span> <span style="color:#f92672">-</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">relativePositionInSegment</span>
  <span style="color:#f92672">}</span>

  def messageOffsetOnly<span style="color:#f92672">:</span> Boolean <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    segmentBaseOffset <span style="color:#f92672">==</span> Log<span style="color:#f92672">.</span><span style="color:#a6e22e">UnknownOffset</span> <span style="color:#f92672">&amp;&amp;</span> relativePositionInSegment <span style="color:#f92672">==</span> LogOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">UnknownFilePosition</span>
  <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p><code>messageOffset 参数</code>：消息位移值，这是最重要的信息。我们总说高水位值，其实指的就是这个变量的值。</p>
</li>
<li>
<p><code>segmentBaseOffset 参数</code>：保存该位移值所在日志段的起始位移。日志段起始位移值辅助计算两条消息在物理磁盘文件中位置的差值，即两条消息彼此隔了多少字节。</p>
<ul>
<li>这个计算有个前提条件，即两条消息必须处在同一个日志段对象上，不能跨日志段对象。否则它们就位于不同的物理文件上，计算这个值就没有意义了。</li>
<li>这里的 segmentBaseOffset，就是用来判断两条消息是否处于同一个日志段的。</li>
</ul>
</li>
<li>
<p><code>relativePositionInSegment 参数</code>：保存该位移值所在日志段的物理磁盘位置。这个字段在计算两个位移值之间的物理磁盘位置差值时非常有用。</p>
</li>
<li>
<p><code>onOlderSegment( )方法</code>：判断给定的 <code>LogOffsetMetadata</code> 对象是否是在新的日志段</p>
</li>
<li>
<p><code>onSameSegment( )方法</code>：来判断给定的两个 <code>LogOffsetMetadata</code> 对象是否处于同一个日志段的</p>
</li>
<li>
<p><code>offsetDiff( )方法</code>：计算两个<code>LogOffsetMetadata</code> 对象中隔了多少消息(offset 差值)</p>
</li>
<li>
<p><code>positionDiff( )方法</code>：计算两个 <code>LogOffsetMetadata</code> 对象的物理位置差值。</p>
</li>
</ul>
<p><strong>2.7.2.1 获取和设置高水位</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// getter method：读取高水位的位移值
</span><span style="color:#75715e"></span>def highWatermark<span style="color:#f92672">:</span> Long <span style="color:#f92672">=</span> highWatermarkMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span>

<span style="color:#75715e">// setter method：设置高水位值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">updateHighWatermarkMetadata</span><span style="color:#f92672">(</span>newHighWatermark<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">):</span> Unit <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newHighWatermark<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#75715e">// 高水位值不能是负数
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;High watermark offset should be non-negative&#34;</span><span style="color:#f92672">)</span>

    lock <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 保护Log对象修改的Monitor锁
</span><span style="color:#75715e"></span>      highWatermarkMetadata <span style="color:#f92672">=</span> newHighWatermark <span style="color:#75715e">// 赋值新的高水位值
</span><span style="color:#75715e"></span>      producerStateManager<span style="color:#f92672">.</span><span style="color:#a6e22e">onHighWatermarkUpdated</span><span style="color:#f92672">(</span>newHighWatermark<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span><span style="color:#f92672">)</span> <span style="color:#75715e">// 处理事务状态管理器的高水位值更新逻辑，忽略它……
</span><span style="color:#75715e"></span>      maybeIncrementFirstUnstableOffset<span style="color:#f92672">()</span> <span style="color:#75715e">// First Unstable Offset是Kafka事务机制的一部分
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    trace<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Setting high watermark $newHighWatermark&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>

</code></pre></div><p><strong>2.7.2.2 更新高水位</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// updateHighWatermark method
</span><span style="color:#75715e"></span>def <span style="color:#a6e22e">updateHighWatermark</span><span style="color:#f92672">(</span>hw<span style="color:#f92672">:</span> Long<span style="color:#f92672">):</span> Long <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 新高水位值一定介于[Log Start Offset，Log End Offset]之间
</span><span style="color:#75715e"></span>    val newHighWatermark <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hw <span style="color:#f92672">&lt;</span> logStartOffset<span style="color:#f92672">)</span>  
      logStartOffset
    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> <span style="color:#f92672">(</span>hw <span style="color:#f92672">&gt;</span> logEndOffset<span style="color:#f92672">)</span>
      logEndOffset
    <span style="color:#66d9ef">else</span>
  hw
    <span style="color:#75715e">// 调用Setter方法来更新高水位值
</span><span style="color:#75715e"></span>    updateHighWatermarkMetadata<span style="color:#f92672">(</span>LogOffsetMetadata<span style="color:#f92672">(</span>newHighWatermark<span style="color:#f92672">))</span>
    newHighWatermark  <span style="color:#75715e">// 最后返回新高水位值
</span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>

<span style="color:#75715e">// maybeIncrementHighWatermark method
</span><span style="color:#75715e"></span>def <span style="color:#a6e22e">maybeIncrementHighWatermark</span><span style="color:#f92672">(</span>newHighWatermark<span style="color:#f92672">:</span> LogOffsetMetadata<span style="color:#f92672">):</span> Option<span style="color:#f92672">[</span>LogOffsetMetadata<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 新高水位值不能越过Log End Offset
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newHighWatermark<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span> <span style="color:#f92672">&gt;</span> logEndOffset<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;High watermark $newHighWatermark update exceeds current &#34;</span> <span style="color:#f92672">+</span>
        s<span style="color:#e6db74">&#34;log end offset $logEndOffsetMetadata&#34;</span><span style="color:#f92672">)</span>

    lock<span style="color:#f92672">.</span><span style="color:#a6e22e">synchronized</span> <span style="color:#f92672">{</span>
      val oldHighWatermark <span style="color:#f92672">=</span> fetchHighWatermarkMetadata  <span style="color:#75715e">// 获取老的高水位值
</span><span style="color:#75715e"></span>
      <span style="color:#75715e">// 新高水位值要比老高水位值大以维持单调增加特性，否则就不做更新！
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 另外，如果新高水位值在新日志段上，也可执行更新高水位操作
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldHighWatermark<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span> <span style="color:#f92672">&lt;</span> newHighWatermark<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span> <span style="color:#f92672">||</span>
        <span style="color:#f92672">(</span>oldHighWatermark<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span> <span style="color:#f92672">==</span> newHighWatermark<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span> <span style="color:#f92672">&amp;&amp;</span> oldHighWatermark<span style="color:#f92672">.</span><span style="color:#a6e22e">onOlderSegment</span><span style="color:#f92672">(</span>newHighWatermark<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
        updateHighWatermarkMetadata<span style="color:#f92672">(</span>newHighWatermark<span style="color:#f92672">)</span>
        Some<span style="color:#f92672">(</span>oldHighWatermark<span style="color:#f92672">)</span> <span style="color:#75715e">// 返回老的高水位值
</span><span style="color:#75715e"></span>      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        None
      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
</code></pre></div><p>更新高水位有两个方法一个是 <code>updateHighWatermark</code> 和 <code>maybeIncrementHighWatermark</code></p>
<ul>
<li><code>updateHighWatermark</code>：主要是Follower 副本从 Leader 副本获取到消息后更新高水位值。一旦拿到立即更新</li>
<li><code>maybeIncrementHighWatermark</code>：主要是Leader 副本接收Producer 消息，它不会立即更新，而是要根据一定的条件来会更新。
<ul>
<li>新高水位值要比老高水位值大以维持单调增加特性，否则就不做更新。</li>
<li>如果新高水位值在新日志段上，也可执行更新高水位操作。</li>
</ul>
</li>
</ul>
<p><strong>2.7.2.3 读取高水位</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def fetchHighWatermarkMetadata<span style="color:#f92672">:</span> LogOffsetMetadata <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    checkIfMemoryMappedBufferClosed<span style="color:#f92672">()</span> <span style="color:#75715e">// 读取时确保日志不能被关闭
</span><span style="color:#75715e"></span>
    val offsetMetadata <span style="color:#f92672">=</span> highWatermarkMetadata <span style="color:#75715e">// 保存当前高水位值到本地变量，避免多线程访问干扰
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>offsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffsetOnly</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">//没有获得到完整的高水位元数据
</span><span style="color:#75715e"></span>      lock<span style="color:#f92672">.</span><span style="color:#a6e22e">synchronized</span> <span style="color:#f92672">{</span>
        val fullOffset <span style="color:#f92672">=</span> convertToOffsetMetadataOrThrow<span style="color:#f92672">(</span>highWatermark<span style="color:#f92672">)</span> <span style="color:#75715e">// 通过读日志文件的方式把完整的高水位元数据信息拉出来
</span><span style="color:#75715e"></span>        updateHighWatermarkMetadata<span style="color:#f92672">(</span>fullOffset<span style="color:#f92672">)</span> <span style="color:#75715e">// 然后再更新一下高水位对象
</span><span style="color:#75715e"></span>        fullOffset
      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 否则，直接返回即可
</span><span style="color:#75715e"></span>      offsetMetadata
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h4 id="273-logsegment-日志分段">2.7.3 LogSegment 日志分段</h4>
<p>通过Java中的 ConcurrentSkipListMap 进行存储，线程安全。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> val segments<span style="color:#f92672">:</span> ConcurrentNavigableMap<span style="color:#f92672">[</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">lang</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Long</span><span style="color:#f92672">,</span> LogSegment<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentSkipListMap<span style="color:#f92672">[</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">lang</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Long</span><span style="color:#f92672">,</span> LogSegment<span style="color:#f92672">]</span>

<span style="color:#75715e">//主要方法
</span><span style="color:#75715e"></span>def <span style="color:#a6e22e">deleteOldSegments</span><span style="color:#f92672">():</span> Int <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>config<span style="color:#f92672">.</span><span style="color:#a6e22e">delete</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      deleteRetentionMsBreachedSegments<span style="color:#f92672">()</span> <span style="color:#f92672">+</span> deleteRetentionSizeBreachedSegments<span style="color:#f92672">()</span> <span style="color:#f92672">+</span> deleteLogStartOffsetBreachedSegments<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
      deleteLogStartOffsetBreachedSegments<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>


<span style="color:#75715e">// deleteRetentionMsBreachedSegments 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">deleteRetentionMsBreachedSegments</span><span style="color:#f92672">():</span> Int <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>config<span style="color:#f92672">.</span><span style="color:#a6e22e">retentionMs</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0
    val startMs <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span><span style="color:#a6e22e">milliseconds</span>
    <span style="color:#a6e22e">deleteOldSegments</span><span style="color:#f92672">((</span>segment<span style="color:#f92672">,</span> _<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> startMs <span style="color:#f92672">-</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">largestTimestamp</span> <span style="color:#f92672">&gt;</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">retentionMs</span><span style="color:#f92672">,</span>
      reason <span style="color:#f92672">=</span> s<span style="color:#e6db74">&#34;retention time ${config.retentionMs}ms breach&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>

<span style="color:#75715e">// deleteRetentionSizeBreachedSegments 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">deleteRetentionSizeBreachedSegments</span><span style="color:#f92672">():</span> Int <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>config<span style="color:#f92672">.</span><span style="color:#a6e22e">retentionSize</span> <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> size <span style="color:#f92672">&lt;</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">retentionSize</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0
    var diff <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">retentionSize</span>
    def <span style="color:#a6e22e">shouldDelete</span><span style="color:#f92672">(</span>segment<span style="color:#f92672">:</span> LogSegment<span style="color:#f92672">,</span> nextSegmentOpt<span style="color:#f92672">:</span> Option<span style="color:#f92672">[</span>LogSegment<span style="color:#f92672">])</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>diff <span style="color:#f92672">-</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        diff <span style="color:#f92672">-=</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span>
        <span style="color:#66d9ef">true</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">false</span>
      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    deleteOldSegments<span style="color:#f92672">(</span>shouldDelete<span style="color:#f92672">,</span> reason <span style="color:#f92672">=</span> s<span style="color:#e6db74">&#34;retention size in bytes ${config.retentionSize} breach&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>

<span style="color:#75715e">// deleteLogStartOffsetBreachedSegments 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">deleteLogStartOffsetBreachedSegments</span><span style="color:#f92672">():</span> Int <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    def <span style="color:#a6e22e">shouldDelete</span><span style="color:#f92672">(</span>segment<span style="color:#f92672">:</span> LogSegment<span style="color:#f92672">,</span> nextSegmentOpt<span style="color:#f92672">:</span> Option<span style="color:#f92672">[</span>LogSegment<span style="color:#f92672">])</span> <span style="color:#f92672">=</span>
      nextSegmentOpt<span style="color:#f92672">.</span><span style="color:#a6e22e">exists</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span> <span style="color:#f92672">&lt;=</span> logStartOffset<span style="color:#f92672">)</span>

    deleteOldSegments<span style="color:#f92672">(</span>shouldDelete<span style="color:#f92672">,</span> reason <span style="color:#f92672">=</span> s<span style="color:#e6db74">&#34;log start offset $logStartOffset breach&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>
</code></pre></div><p>这三个方法都调用了 <code>deleteOldSegments</code> 方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">deleteOldSegments</span><span style="color:#f92672">(</span>predicate<span style="color:#f92672">:</span> <span style="color:#f92672">(</span>LogSegment<span style="color:#f92672">,</span> Option<span style="color:#f92672">[</span>LogSegment<span style="color:#f92672">])</span> <span style="color:#f92672">=&gt;</span> Boolean<span style="color:#f92672">,</span> reason<span style="color:#f92672">:</span> String<span style="color:#f92672">):</span> Int <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    lock <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">//① 使用传入的函数计算哪些日志段对象能够被删除
</span><span style="color:#75715e"></span>      val deletable <span style="color:#f92672">=</span> deletableSegments<span style="color:#f92672">(</span>predicate<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>deletable<span style="color:#f92672">.</span><span style="color:#a6e22e">nonEmpty</span><span style="color:#f92672">)</span>
        info<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Found deletable segments with base offsets [${deletable.map(_.baseOffset).mkString(&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;)}] due to $reason&#34;</span><span style="color:#f92672">)</span>
      <span style="color:#75715e">//② 删除这些日志段
</span><span style="color:#75715e"></span>      deleteSegments<span style="color:#f92672">(</span>deletable<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>① 使用传入的函数计算哪些日志段对象能够被删除
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">deletableSegments</span><span style="color:#f92672">(</span>predicate<span style="color:#f92672">:</span> <span style="color:#f92672">(</span>LogSegment<span style="color:#f92672">,</span> Option<span style="color:#f92672">[</span>LogSegment<span style="color:#f92672">])</span> <span style="color:#f92672">=&gt;</span> Boolean<span style="color:#f92672">):</span> Iterable<span style="color:#f92672">[</span>LogSegment<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">// 如果当前压根就没有任何日志段对象，直接返回
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>segments<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Seq<span style="color:#f92672">.</span><span style="color:#a6e22e">empty</span>
  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
    val deletable <span style="color:#f92672">=</span> ArrayBuffer<span style="color:#f92672">.</span><span style="color:#a6e22e">empty</span><span style="color:#f92672">[</span>LogSegment<span style="color:#f92672">]</span>
    var segmentEntry <span style="color:#f92672">=</span> segments<span style="color:#f92672">.</span><span style="color:#a6e22e">firstEntry</span>
    <span style="color:#75715e">// 从具有最小起始位移值的日志段对象开始遍历，直到满足以下条件之一便停止遍历：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//1. 测定条件函数predicate = false
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//2. 扫描到包含Log对象高水位值所在的日志段对象
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//3. 最新的日志段对象不包含任何消息
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//最新日志段对象是segments中Key值最大对应的那个日志段，也就是我们常说的Active Segment。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//完全为空的Active Segment如果被允许删除，后面还要重建它，故代码这里不允许删除大小为空的Active Segment。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//在遍历过程中，同时不满足以上3个条件的所有日志段都是可以被删除的！
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>segmentEntry <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      val segment <span style="color:#f92672">=</span> segmentEntry<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span>
      val nextSegmentEntry <span style="color:#f92672">=</span> segments<span style="color:#f92672">.</span><span style="color:#a6e22e">higherEntry</span><span style="color:#f92672">(</span>segmentEntry<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">)</span>
      val <span style="color:#f92672">(</span>nextSegment<span style="color:#f92672">,</span> upperBoundOffset<span style="color:#f92672">,</span> isLastSegmentAndEmpty<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nextSegmentEntry <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">(</span>nextSegmentEntry<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">,</span> nextSegmentEntry<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
      <span style="color:#66d9ef">else</span>
        <span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> logEndOffset<span style="color:#f92672">,</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>

      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>highWatermark <span style="color:#f92672">&gt;=</span> upperBoundOffset <span style="color:#f92672">&amp;&amp;</span> predicate<span style="color:#f92672">(</span>segment<span style="color:#f92672">,</span> Option<span style="color:#f92672">(</span>nextSegment<span style="color:#f92672">))</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isLastSegmentAndEmpty<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        deletable <span style="color:#f92672">+=</span> segment
        segmentEntry <span style="color:#f92672">=</span> nextSegmentEntry
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        segmentEntry <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>
      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    deletable
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>② 删除这些日志段
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">deleteSegments</span><span style="color:#f92672">(</span>deletable<span style="color:#f92672">:</span> Iterable<span style="color:#f92672">[</span>LogSegment<span style="color:#f92672">]):</span> Int <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  maybeHandleIOException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Error while deleting segments for $topicPartition in dir ${dir.getParent}&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val numToDelete <span style="color:#f92672">=</span> deletable<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span>
    <span style="color:#a6e22e">if</span> <span style="color:#f92672">(</span>numToDelete <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">// we must always have at least one segment, so if we are going to delete all the segments, create a new one first
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 不允许删除所有日志段对象。如果一定要做，先创建出一个新的来，然后再把前面N个删掉
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>segments<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">==</span> numToDelete<span style="color:#f92672">)</span>
        roll<span style="color:#f92672">()</span>
      lock <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">{</span>
        checkIfMemoryMappedBufferClosed<span style="color:#f92672">()</span><span style="color:#75715e">// 确保Log对象没有被关闭
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// remove the segments for lookups
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 删除给定的日志段对象以及底层的物理文件
</span><span style="color:#75715e"></span>        removeAndDeleteSegments<span style="color:#f92672">(</span>deletable<span style="color:#f92672">,</span> asyncDelete <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
        <span style="color:#75715e">// 尝试更新日志的Log Start Offset值
</span><span style="color:#75715e"></span>        maybeIncrementLogStartOffset<span style="color:#f92672">(</span>segments<span style="color:#f92672">.</span><span style="color:#a6e22e">firstEntry</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">)</span>
      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    numToDelete
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<hr>
<h4 id="274-日志位移">2.7.4 日志位移</h4>
<p>Log 对象维护了一些关键位移值数据，比如 <code>Log Start Offset</code>、<code>LEO</code> 等。
<img src="http://img.sirann.cn//siran/20200502154042.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//LEO的定义
</span><span style="color:#75715e"></span><span style="color:#a6e22e">@volatile</span> <span style="color:#66d9ef">private</span> var nextOffsetMetadata<span style="color:#f92672">:</span> LogOffsetMetadata <span style="color:#f92672">=</span> _

<span style="color:#75715e">//更新 LEO 的方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">updateLogEndOffset</span><span style="color:#f92672">(</span>offset<span style="color:#f92672">:</span> Long<span style="color:#f92672">):</span> Unit <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  nextOffsetMetadata <span style="color:#f92672">=</span> LogOffsetMetadata<span style="color:#f92672">(</span>offset<span style="color:#f92672">,</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">,</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">)</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>highWatermark <span style="color:#f92672">&gt;=</span> offset<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    updateHighWatermarkMetadata<span style="color:#f92672">(</span>nextOffsetMetadata<span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">recoveryPoint</span> <span style="color:#f92672">&gt;</span> offset<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">recoveryPoint</span> <span style="color:#f92672">=</span> offset
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p><strong>LEO 会被更新的时机</strong>：</p>
<ul>
<li><code>Log 对象初始化时</code>：当 Log 对象初始化时，我们必须要创建一个 LEO 对象，并对其进行初始化。</li>
<li><code>写入新消息时</code>：以上面的图为例，当不断向 Log 对象插入新消息时，LEO 值就像一个指针一样，需要不停地向右移动，也就是不断地增加。</li>
<li><code>Log 对象发生日志切分（Log Roll）时</code>：在创建一个新的 <code>LogSegment</code> 的时候，并且关闭当前写入的日志段对象。这通常发生在当前日志段对象已满的时候。一旦发生日志切分，说明 Log 对象切换了 Active Segment，那么，LEO 中的起始位移值和段大小数据都要被更新，因此，在进行这一步操作时，我们必须要更新 LEO 对象。</li>
<li><code>日志截断（Log Truncation）时</code>：日志中的部分消息被删除了，自然可能导致 LEO 值发生变化，从而要更新 LEO 对象。</li>
</ul>
</li>
<li>
<p><strong>Log Start Offset 会被更新的时机</strong>：</p>
<ul>
<li><code>Log 对象初始化时</code>：和 LEO 类似，Log 对象初始化时要给 <code>Log Start Offset</code> 赋值，一般是将第一个日志段的起始位移值赋值给它。</li>
<li><code>日志截断时</code>：同理，一旦日志中的部分消息被删除，可能会导致 <code>Log Start Offset</code> 发生变化，因此有必要更新该值。</li>
<li><code>Follower 副本同步时</code>：一旦 Leader 副本的 Log 对象的 Log Start Offset 值发生变化。为了维持和 Leader 副本的一致性，Follower 副本也需要尝试去更新该值。</li>
<li><code>删除日志段时</code>：这个和日志截断是类似的。凡是涉及消息删除的操作都有可能导致 Log Start Offset 值的变化。删除消息时：严格来说，这个更新时机有点本末倒置了。在 Kafka 中，删除消息就是通过抬高 Log Start Offset 值来实现的，因此，删除消息时必须要更新该值。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="275-读写操作">2.7.5 读写操作</h4>
<h4 id="append-写操作">append 写操作</h4>
<p>添加消息到 Log 中，相关写操作有3个： <code>appendAsLeader</code> 、 <code>appendAsFollower</code> 、 <code>append</code> ，调用关系如下：
<img src="http://img.sirann.cn//siran/20200502162018.png" alt=""></p>
<ul>
<li>appendAsLeader 是用于写 <code>Leader</code> 副本的</li>
<li>appendAsFollower 是用于 <code>Follower</code> 副本同步的。</li>
<li>它们的底层都调用了 append 方法。</li>
</ul>
<p><strong>下图是 append 方法的执行流程：</strong></p>
<p><img src="http://img.sirann.cn//siran/20200502162309.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>records<span style="color:#f92672">:</span> MemoryRecords<span style="color:#f92672">,</span>
                     origin<span style="color:#f92672">:</span> AppendOrigin<span style="color:#f92672">,</span>
                     interBrokerProtocolVersion<span style="color:#f92672">:</span> ApiVersion<span style="color:#f92672">,</span>
                     assignOffsets<span style="color:#f92672">:</span> Boolean<span style="color:#f92672">,</span>
                     leaderEpoch<span style="color:#f92672">:</span> Int<span style="color:#f92672">):</span> LogAppendInfo <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    maybeHandleIOException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Error while appending records to $topicPartition in dir ${dir.getParent}&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">// ① 分析和验证待写入消息集合，并返回校验结果，验证消息的长度、crc32校验码、内部offset 是否单调递增，都是对外层消息进行的，并不会解压内部的压缩消息
</span><span style="color:#75715e"></span>      val appendInfo <span style="color:#f92672">=</span> analyzeAndValidateRecords<span style="color:#f92672">(</span>records<span style="color:#f92672">,</span> origin<span style="color:#f92672">)</span>

      <span style="color:#75715e">// return if we have no valid messages or if this is a duplicate of the last appended entry
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 如果压根就不需要写入任何消息，直接返回即可(也就是说在第①步中没有发现有message 这个这里 shallowCount 是0)
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">shallowCount</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> appendInfo

      <span style="color:#75715e">// trim any invalid bytes or partial messages before appending it to the on-disk log
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// ② 消息格式规整，即删除无效格式消息或无效字节，根据步骤 ① 方法返回的LogAppendInfo 对象，将未通过验证的消息截断
</span><span style="color:#75715e"></span>      var validRecords <span style="color:#f92672">=</span> trimInvalidBytes<span style="color:#f92672">(</span>records<span style="color:#f92672">,</span> appendInfo<span style="color:#f92672">)</span>

      <span style="color:#75715e">// they are valid, insert them in the log
</span><span style="color:#75715e"></span>      lock <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">{</span>
        checkIfMemoryMappedBufferClosed<span style="color:#f92672">()</span><span style="color:#75715e">//确保log对象未关闭
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>assignOffsets<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//需要分配位移
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// assign offsets to the message set
</span><span style="color:#75715e"></span>          <span style="color:#75715e">//③ 使用当前LEO值作为待写入消息集合的第一条消息位移值
</span><span style="color:#75715e"></span>          val offset <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LongRef<span style="color:#f92672">(</span>nextOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span><span style="color:#f92672">)</span>
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOffset</span> <span style="color:#f92672">=</span> Some<span style="color:#f92672">(</span>offset<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">)</span>
          val now <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span><span style="color:#a6e22e">milliseconds</span>
          val validateAndOffsetAssignResult <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            LogValidator<span style="color:#f92672">.</span><span style="color:#a6e22e">validateMessagesAndAssignOffsets</span><span style="color:#f92672">(</span>validRecords<span style="color:#f92672">,</span>
              topicPartition<span style="color:#f92672">,</span>
              offset<span style="color:#f92672">,</span>
              time<span style="color:#f92672">,</span>
              now<span style="color:#f92672">,</span>
              appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">sourceCodec</span><span style="color:#f92672">,</span>
              appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">targetCodec</span><span style="color:#f92672">,</span>
              config<span style="color:#f92672">.</span><span style="color:#a6e22e">compact</span><span style="color:#f92672">,</span>
              config<span style="color:#f92672">.</span><span style="color:#a6e22e">messageFormatVersion</span><span style="color:#f92672">.</span><span style="color:#a6e22e">recordVersion</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">,</span>
              config<span style="color:#f92672">.</span><span style="color:#a6e22e">messageTimestampType</span><span style="color:#f92672">,</span>
              config<span style="color:#f92672">.</span><span style="color:#a6e22e">messageTimestampDifferenceMaxMs</span><span style="color:#f92672">,</span>
              leaderEpoch<span style="color:#f92672">,</span>
              origin<span style="color:#f92672">,</span>
              interBrokerProtocolVersion<span style="color:#f92672">,</span>
              brokerTopicStats<span style="color:#f92672">)</span>
          <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">case</span> e<span style="color:#f92672">:</span> IOException <span style="color:#f92672">=&gt;</span>
              <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> KafkaException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Error validating messages while appending to log $name&#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">)</span>
          <span style="color:#f92672">}</span>
          <span style="color:#75715e">//更新校验结果对象类 LogAppendInfo
</span><span style="color:#75715e"></span>          validRecords <span style="color:#f92672">=</span> validateAndOffsetAssignResult<span style="color:#f92672">.</span><span style="color:#a6e22e">validatedRecords</span>
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">maxTimestamp</span> <span style="color:#f92672">=</span> validateAndOffsetAssignResult<span style="color:#f92672">.</span><span style="color:#a6e22e">maxTimestamp</span>
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">offsetOfMaxTimestamp</span> <span style="color:#f92672">=</span> validateAndOffsetAssignResult<span style="color:#f92672">.</span><span style="color:#a6e22e">shallowOffsetOfMaxTimestamp</span>
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span> <span style="color:#f92672">=</span> offset<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">-</span> 1
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">recordConversionStats</span> <span style="color:#f92672">=</span> validateAndOffsetAssignResult<span style="color:#f92672">.</span><span style="color:#a6e22e">recordConversionStats</span>
          <span style="color:#a6e22e">if</span> <span style="color:#f92672">(</span>config<span style="color:#f92672">.</span><span style="color:#a6e22e">messageTimestampType</span> <span style="color:#f92672">==</span> TimestampType<span style="color:#f92672">.</span><span style="color:#a6e22e">LOG_APPEND_TIME</span><span style="color:#f92672">)</span>
            appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">logAppendTime</span> <span style="color:#f92672">=</span> now

          <span style="color:#75715e">// re-validate message sizes if there&#39;s a possibility that they have changed (due to re-compression or message
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// format conversion)
</span><span style="color:#75715e"></span>          <span style="color:#75715e">//④ 验证消息，保证消息大小不超限
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>validateAndOffsetAssignResult<span style="color:#f92672">.</span><span style="color:#a6e22e">messageSizeMaybeChanged</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>batch <span style="color:#f92672">&lt;-</span> validRecords<span style="color:#f92672">.</span><span style="color:#a6e22e">batches</span><span style="color:#f92672">.</span><span style="color:#a6e22e">asScala</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
              <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span> <span style="color:#f92672">&gt;</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">maxMessageSize</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// we record the original message set size instead of the trimmed size
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// to be consistent with pre-compression bytesRejectedRate recording
</span><span style="color:#75715e"></span>                brokerTopicStats<span style="color:#f92672">.</span><span style="color:#a6e22e">topicStats</span><span style="color:#f92672">(</span>topicPartition<span style="color:#f92672">.</span><span style="color:#a6e22e">topic</span><span style="color:#f92672">).</span><span style="color:#a6e22e">bytesRejectedRate</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mark</span><span style="color:#f92672">(</span>records<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span><span style="color:#f92672">)</span>
                brokerTopicStats<span style="color:#f92672">.</span><span style="color:#a6e22e">allTopicsStats</span><span style="color:#f92672">.</span><span style="color:#a6e22e">bytesRejectedRate</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mark</span><span style="color:#f92672">(</span>records<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span><span style="color:#f92672">)</span>
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RecordTooLargeException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Message batch size is ${batch.sizeInBytes} bytes in append to&#34;</span> <span style="color:#f92672">+</span>
                  s<span style="color:#e6db74">&#34;partition $topicPartition which exceeds the maximum configured size of ${config.maxMessageSize}.&#34;</span><span style="color:#f92672">)</span>
              <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
          <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span><span style="color:#75715e">//直接使用给定的移位值，无需自己分配位移值
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// we are taking the offsets we are given
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">offsetsMonotonic</span><span style="color:#f92672">)</span><span style="color:#75715e">//确保消息移植的单调递增性
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> OffsetsOutOfOrderException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Out of order offsets found in append to $topicPartition: &#34;</span> <span style="color:#f92672">+</span>
                                                 records<span style="color:#f92672">.</span><span style="color:#a6e22e">records</span><span style="color:#f92672">.</span><span style="color:#a6e22e">asScala</span><span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">offset</span><span style="color:#f92672">))</span>

          <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOrLastOffsetOfFirstBatch</span> <span style="color:#f92672">&lt;</span> nextOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// we may still be able to recover if the log is empty
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// one example: fetching from log start offset on the leader which is not batch aligned,
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// which may happen as a result of AdminClient#deleteRecords()
</span><span style="color:#75715e"></span>            val firstOffset <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOffset</span> match <span style="color:#f92672">{</span>
              <span style="color:#66d9ef">case</span> Some<span style="color:#f92672">(</span>offset<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> offset
              <span style="color:#66d9ef">case</span> None <span style="color:#f92672">=&gt;</span> records<span style="color:#f92672">.</span><span style="color:#a6e22e">batches</span><span style="color:#f92672">.</span><span style="color:#a6e22e">asScala</span><span style="color:#f92672">.</span><span style="color:#a6e22e">head</span><span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">()</span>
            <span style="color:#f92672">}</span>

            val firstOrLast <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOffset</span><span style="color:#f92672">.</span><span style="color:#a6e22e">isDefined</span><span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;First offset&#34;</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;Last offset of the first batch&#34;</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UnexpectedAppendOffsetException<span style="color:#f92672">(</span>
              s<span style="color:#e6db74">&#34;Unexpected offset in append to $topicPartition. $firstOrLast &#34;</span> <span style="color:#f92672">+</span>
              s<span style="color:#e6db74">&#34;${appendInfo.firstOrLastOffsetOfFirstBatch} is less than the next offset ${nextOffsetMetadata.messageOffset}. &#34;</span> <span style="color:#f92672">+</span>
              s<span style="color:#e6db74">&#34;First 10 offsets in append: ${records.records.asScala.take(10).map(_.offset)}, last offset in&#34;</span> <span style="color:#f92672">+</span>
              s<span style="color:#e6db74">&#34; append: ${appendInfo.lastOffset}. Log start offset = $logStartOffset&#34;</span><span style="color:#f92672">,</span>
              firstOffset<span style="color:#f92672">,</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span><span style="color:#f92672">)</span>
          <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// update the epoch cache with the epoch stamped onto the message by the leader
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//⑤ 更新Leader Epoch缓存
</span><span style="color:#75715e"></span>        validRecords<span style="color:#f92672">.</span><span style="color:#a6e22e">batches</span><span style="color:#f92672">.</span><span style="color:#a6e22e">asScala</span><span style="color:#f92672">.</span><span style="color:#a6e22e">foreach</span> <span style="color:#f92672">{</span> batch <span style="color:#f92672">=&gt;</span>
          <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">magic</span> <span style="color:#f92672">&gt;=</span> RecordBatch<span style="color:#f92672">.</span><span style="color:#a6e22e">MAGIC_VALUE_V2</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            maybeAssignEpochStartOffset<span style="color:#f92672">(</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">partitionLeaderEpoch</span><span style="color:#f92672">,</span> batch<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">)</span>
          <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// In partial upgrade scenarios, we may get a temporary regression to the message format. In
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// order to ensure the safety of leader election, we clear the epoch cache so that we revert
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// to truncation by high watermark after the next leader election.
</span><span style="color:#75715e"></span>            leaderEpochCache<span style="color:#f92672">.</span><span style="color:#a6e22e">filter</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">nonEmpty</span><span style="color:#f92672">).</span><span style="color:#a6e22e">foreach</span> <span style="color:#f92672">{</span> cache <span style="color:#f92672">=&gt;</span>
              warn<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Clearing leader epoch cache after unexpected append with message format v${batch.magic}&#34;</span><span style="color:#f92672">)</span>
              cache<span style="color:#f92672">.</span><span style="color:#a6e22e">clearAndFlush</span><span style="color:#f92672">()</span>
            <span style="color:#f92672">}</span>
          <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// check messages set size may be exceed config.segmentSize
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//⑥ 确保消息大小不超限
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>validRecords<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span> <span style="color:#f92672">&gt;</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">segmentSize</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RecordBatchTooLargeException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Message batch size is ${validRecords.sizeInBytes} bytes in append &#34;</span> <span style="color:#f92672">+</span>
            s<span style="color:#e6db74">&#34;to partition $topicPartition, which exceeds the maximum configured segment size of ${config.segmentSize}.&#34;</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// maybe roll the log if this segment is full
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//⑦ 执行日志切分，当前日志断剩余容量可能无法容纳新消息集合，因此要创建一个(如果满足需要创建一个新的activeSegment，然后返回当前的activeSegment)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 1. 当前activeSegment 的日志大小加上本次待追加的消息集合大小，超过配置的LogSegment 的最大长度
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 2. 当前activeSegment 的寿命超过了配置的 LogSegment 最长存活时间
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 3. 索引文件满了
</span><span style="color:#75715e"></span>        val segment <span style="color:#f92672">=</span> maybeRoll<span style="color:#f92672">(</span>validRecords<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span><span style="color:#f92672">,</span> appendInfo<span style="color:#f92672">)</span>

        val logOffsetMetadata <span style="color:#f92672">=</span> LogOffsetMetadata<span style="color:#f92672">(</span>
          messageOffset <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOrLastOffsetOfFirstBatch</span><span style="color:#f92672">,</span>
          segmentBaseOffset <span style="color:#f92672">=</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">,</span>
          relativePositionInSegment <span style="color:#f92672">=</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">)</span>

        <span style="color:#75715e">// now that we have valid records, offsets assigned, and timestamps updated, we need to
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// validate the idempotent/transactional state of the producers and collect some metadata
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//⑧ 验证事务状态
</span><span style="color:#75715e"></span>        val <span style="color:#f92672">(</span>updatedProducers<span style="color:#f92672">,</span> completedTxns<span style="color:#f92672">,</span> maybeDuplicate<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> analyzeAndValidateProducerState<span style="color:#f92672">(</span>
          logOffsetMetadata<span style="color:#f92672">,</span> validRecords<span style="color:#f92672">,</span> origin<span style="color:#f92672">)</span>

        maybeDuplicate<span style="color:#f92672">.</span><span style="color:#a6e22e">foreach</span> <span style="color:#f92672">{</span> duplicate <span style="color:#f92672">=&gt;</span>
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOffset</span> <span style="color:#f92672">=</span> Some<span style="color:#f92672">(</span>duplicate<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOffset</span><span style="color:#f92672">)</span>
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span> <span style="color:#f92672">=</span> duplicate<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span>
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">logAppendTime</span> <span style="color:#f92672">=</span> duplicate<span style="color:#f92672">.</span><span style="color:#a6e22e">timestamp</span>
          appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">logStartOffset</span> <span style="color:#f92672">=</span> logStartOffset
          <span style="color:#66d9ef">return</span> appendInfo
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//⑨：执行真正的消息写入操作，主要调用日志段对象的append方法实现
</span><span style="color:#75715e"></span>        segment<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>largestOffset <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span><span style="color:#f92672">,</span>
          largestTimestamp <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">maxTimestamp</span><span style="color:#f92672">,</span>
          shallowOffsetOfMaxTimestamp <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">offsetOfMaxTimestamp</span><span style="color:#f92672">,</span>
          records <span style="color:#f92672">=</span> validRecords<span style="color:#f92672">)</span>

        <span style="color:#75715e">// ⑩：更新LEO对象，其中，LEO值是消息集合中最后一条消息位移值+1
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//前面说过，LEO值永远指向下一条不存在的消息
</span><span style="color:#75715e"></span>        updateLogEndOffset<span style="color:#f92672">(</span>appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span>

        <span style="color:#75715e">// update the producer state
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//⑪：更新事务状态
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>producerAppendInfo <span style="color:#f92672">&lt;-</span> updatedProducers<span style="color:#f92672">.</span><span style="color:#a6e22e">values</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          producerStateManager<span style="color:#f92672">.</span><span style="color:#a6e22e">update</span><span style="color:#f92672">(</span>producerAppendInfo<span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// update the transaction index with the true last stable offset. The last offset visible
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// to consumers using READ_COMMITTED will be limited by this value and the high watermark.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>completedTxn <span style="color:#f92672">&lt;-</span> completedTxns<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          val lastStableOffset <span style="color:#f92672">=</span> producerStateManager<span style="color:#f92672">.</span><span style="color:#a6e22e">lastStableOffset</span><span style="color:#f92672">(</span>completedTxn<span style="color:#f92672">)</span>
          segment<span style="color:#f92672">.</span><span style="color:#a6e22e">updateTxnIndex</span><span style="color:#f92672">(</span>completedTxn<span style="color:#f92672">,</span> lastStableOffset<span style="color:#f92672">)</span>
          producerStateManager<span style="color:#f92672">.</span><span style="color:#a6e22e">completeTxn</span><span style="color:#f92672">(</span>completedTxn<span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// always update the last producer id map offset so that the snapshot reflects the current offset
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// even if there isn&#39;t any idempotent data being written
</span><span style="color:#75715e"></span>        producerStateManager<span style="color:#f92672">.</span><span style="color:#a6e22e">updateMapEndOffset</span><span style="color:#f92672">(</span>appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span>

        <span style="color:#75715e">// update the first unstable offset (which is used to compute LSO)
</span><span style="color:#75715e"></span>        maybeIncrementFirstUnstableOffset<span style="color:#f92672">()</span>

        trace<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Appended message set with last offset: ${appendInfo.lastOffset}, &#34;</span> <span style="color:#f92672">+</span>
          s<span style="color:#e6db74">&#34;first offset: ${appendInfo.firstOffset}, &#34;</span> <span style="color:#f92672">+</span>
          s<span style="color:#e6db74">&#34;next offset: ${nextOffsetMetadata.messageOffset}, &#34;</span> <span style="color:#f92672">+</span>
          s<span style="color:#e6db74">&#34;and messages: $validRecords&#34;</span><span style="color:#f92672">)</span>

        <span style="color:#75715e">// 是否需要手动落盘。一般情况下我们不需要设置Broker端参数log.flush.interval.messages
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 落盘操作交由操作系统来完成。但某些情况下，可以设置该参数来确保高可靠性
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>unflushedMessages <span style="color:#f92672">&gt;=</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">flushInterval</span><span style="color:#f92672">)</span>
          flush<span style="color:#f92672">()</span>

        <span style="color:#75715e">//⑫ 返回写入结果
</span><span style="color:#75715e"></span>        appendInfo
      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p>① 分析和验证待写入消息集合，并返回校验结果，<strong>验证消息的长度、crc32校验码、内部offset 是否单调递增</strong>，都是对<code>外层消息</code>进行的，并不会解压内部的压缩消息</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">analyzeAndValidateRecords</span><span style="color:#f92672">(</span>records<span style="color:#f92672">:</span> MemoryRecords<span style="color:#f92672">,</span> origin<span style="color:#f92672">:</span> AppendOrigin<span style="color:#f92672">):</span> LogAppendInfo <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  var shallowMessageCount <span style="color:#f92672">=</span> 0 <span style="color:#75715e">//记录外层消息的数量
</span><span style="color:#75715e"></span>  var validBytesCount <span style="color:#f92672">=</span> 0 <span style="color:#75715e">//记录通过验证的 records 的字节数之和
</span><span style="color:#75715e"></span>  var firstOffset<span style="color:#f92672">:</span> Option<span style="color:#f92672">[</span>Long<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> None <span style="color:#75715e">//记录第一条消息的offset，就是baseOffset
</span><span style="color:#75715e"></span>  var lastOffset <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1L <span style="color:#75715e">//记录最后一条消息的offset
</span><span style="color:#75715e"></span>  var sourceCodec<span style="color:#f92672">:</span> CompressionCodec <span style="color:#f92672">=</span> NoCompressionCodec <span style="color:#75715e">//消息的压缩方法
</span><span style="color:#75715e"></span>  var monotonic <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span> <span style="color:#75715e">//标识生产者为消息分配的内部 offset 是否单调递增，使用浅层迭代器进行迭代，如果是压缩消息，并不会解压缩
</span><span style="color:#75715e"></span>  var maxTimestamp <span style="color:#f92672">=</span> RecordBatch<span style="color:#f92672">.</span><span style="color:#a6e22e">NO_TIMESTAMP</span> <span style="color:#75715e">//最大的时间戳
</span><span style="color:#75715e"></span>  var offsetOfMaxTimestamp <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1L <span style="color:#75715e">//最大时间戳的offset
</span><span style="color:#75715e"></span>  var readFirstMessage <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span> <span style="color:#75715e">//是否已经读了第一条消息的 offset。也就是这个batch的 baseOffset
</span><span style="color:#75715e"></span>  var lastOffsetOfFirstBatch <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1L <span style="color:#75715e">//和fistOffset 一个意思，只是这个是旧版本 &lt; v2 版本
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>batch <span style="color:#f92672">&lt;-</span> records<span style="color:#f92672">.</span><span style="color:#a6e22e">batches</span><span style="color:#f92672">.</span><span style="color:#a6e22e">asScala</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// we only validate V2 and higher to avoid potential compatibility issues with older clients
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 消息格式Version 2的消息批次，起始位移值必须从0开始
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">magic</span> <span style="color:#f92672">&gt;=</span> RecordBatch<span style="color:#f92672">.</span><span style="color:#a6e22e">MAGIC_VALUE_V2</span> <span style="color:#f92672">&amp;&amp;</span> origin <span style="color:#f92672">==</span> AppendOrigin<span style="color:#f92672">.</span><span style="color:#a6e22e">Client</span> <span style="color:#f92672">&amp;&amp;</span> batch<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidRecordException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;The baseOffset of the record batch in the append to $topicPartition should &#34;</span> <span style="color:#f92672">+</span>
        s<span style="color:#e6db74">&#34;be 0, but it is ${batch.baseOffset}&#34;</span><span style="color:#f92672">)</span>

    <span style="color:#75715e">//一开始readFirstMessage 是 false 会去获取这个 batch 的baseOffset。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//这里有两种获取方式：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//1. 如果是老版本的kafka 那么通过这个batch的 lastOffset。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//2. 如果是新版本的 &gt;= v2，那么在Batch的Header 里面就有这个baseOffset，可以直接获取
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//然后修改 readFirstMessage 为true
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>readFirstMessage<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">magic</span> <span style="color:#f92672">&gt;=</span> RecordBatch<span style="color:#f92672">.</span><span style="color:#a6e22e">MAGIC_VALUE_V2</span><span style="color:#f92672">)</span>
        firstOffset <span style="color:#f92672">=</span> Some<span style="color:#f92672">(</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">)</span> <span style="color:#75715e">// 更新firstOffset字段
</span><span style="color:#75715e"></span>      lastOffsetOfFirstBatch <span style="color:#f92672">=</span> batch<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span> <span style="color:#75715e">// 更新lastOffsetOfFirstBatch字段
</span><span style="color:#75715e"></span>      readFirstMessage <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// check that offsets are monotonically increasing
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//检查1： 一旦出现当前lastOffset不小于下一个batch的lastOffset，说明上一个batch中有消息的位移值大于后面batch的消息
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这违反了位移值单调递增性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>lastOffset <span style="color:#f92672">&gt;=</span> batch<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span><span style="color:#f92672">)</span>
      monotonic <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>

    <span style="color:#75715e">// update the last offset seen
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 使用当前batch最后一条消息的位移值去更新lastOffset
</span><span style="color:#75715e"></span>    lastOffset <span style="color:#f92672">=</span> batch<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span>

    <span style="color:#75715e">// Check if the message sizes are valid.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//检查2： 检查消息批次总字节数大小是否超限，即是否大于Broker端参数max.message.bytes值
</span><span style="color:#75715e"></span>    val batchSize <span style="color:#f92672">=</span> batch<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span>
    <span style="color:#a6e22e">if</span> <span style="color:#f92672">(</span>batchSize <span style="color:#f92672">&gt;</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">maxMessageSize</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      brokerTopicStats<span style="color:#f92672">.</span><span style="color:#a6e22e">topicStats</span><span style="color:#f92672">(</span>topicPartition<span style="color:#f92672">.</span><span style="color:#a6e22e">topic</span><span style="color:#f92672">).</span><span style="color:#a6e22e">bytesRejectedRate</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mark</span><span style="color:#f92672">(</span>records<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span><span style="color:#f92672">)</span>
      brokerTopicStats<span style="color:#f92672">.</span><span style="color:#a6e22e">allTopicsStats</span><span style="color:#f92672">.</span><span style="color:#a6e22e">bytesRejectedRate</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mark</span><span style="color:#f92672">(</span>records<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span><span style="color:#f92672">)</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RecordTooLargeException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;The record batch size in the append to $topicPartition is $batchSize bytes &#34;</span> <span style="color:#f92672">+</span>
        s<span style="color:#e6db74">&#34;which exceeds the maximum configured value of ${config.maxMessageSize}.&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// check the validity of the message by checking CRC
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//检查3： 执行消息批次校验，包括格式是否正确以及CRC校验
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">isValid</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      brokerTopicStats<span style="color:#f92672">.</span><span style="color:#a6e22e">allTopicsStats</span><span style="color:#f92672">.</span><span style="color:#a6e22e">invalidMessageCrcRecordsPerSec</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mark</span><span style="color:#f92672">()</span>
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> CorruptRecordException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Record is corrupt (stored crc = ${batch.checksum()}) in topic partition $topicPartition.&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 更新maxTimestamp字段和offsetOfMaxTimestamp
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">maxTimestamp</span> <span style="color:#f92672">&gt;</span> maxTimestamp<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      maxTimestamp <span style="color:#f92672">=</span> batch<span style="color:#f92672">.</span><span style="color:#a6e22e">maxTimestamp</span>
      offsetOfMaxTimestamp <span style="color:#f92672">=</span> lastOffset
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 累加消息批次计数器以及有效字节数，更新shallowMessageCount字段
</span><span style="color:#75715e"></span>    shallowMessageCount <span style="color:#f92672">+=</span> 1
    validBytesCount <span style="color:#f92672">+=</span> batchSize

    <span style="color:#75715e">// 从消息批次中获取压缩器类型
</span><span style="color:#75715e"></span>    val messageCodec <span style="color:#f92672">=</span> CompressionCodec<span style="color:#f92672">.</span><span style="color:#a6e22e">getCompressionCodec</span><span style="color:#f92672">(</span>batch<span style="color:#f92672">.</span><span style="color:#a6e22e">compressionType</span><span style="color:#f92672">.</span><span style="color:#a6e22e">id</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>messageCodec <span style="color:#f92672">!=</span> NoCompressionCodec<span style="color:#f92672">)</span>
      sourceCodec <span style="color:#f92672">=</span> messageCodec
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">// Apply broker-side compression if any
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 获取Broker端设置的压缩器类型，即Broker端参数compression.type值。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 该参数默认值是producer，表示sourceCodec用的什么压缩器，targetCodec就用什么
</span><span style="color:#75715e"></span>  val targetCodec <span style="color:#f92672">=</span> BrokerCompressionCodec<span style="color:#f92672">.</span><span style="color:#a6e22e">getTargetCompressionCodec</span><span style="color:#f92672">(</span>config<span style="color:#f92672">.</span><span style="color:#a6e22e">compressionType</span><span style="color:#f92672">,</span> sourceCodec<span style="color:#f92672">)</span>
  <span style="color:#75715e">// 最后生成LogAppendInfo对象并返回
</span><span style="color:#75715e"></span>  LogAppendInfo<span style="color:#f92672">(</span>firstOffset<span style="color:#f92672">,</span> lastOffset<span style="color:#f92672">,</span> maxTimestamp<span style="color:#f92672">,</span> offsetOfMaxTimestamp<span style="color:#f92672">,</span> RecordBatch<span style="color:#f92672">.</span><span style="color:#a6e22e">NO_TIMESTAMP</span><span style="color:#f92672">,</span> logStartOffset<span style="color:#f92672">,</span>
    RecordConversionStats<span style="color:#f92672">.</span><span style="color:#a6e22e">EMPTY</span><span style="color:#f92672">,</span> sourceCodec<span style="color:#f92672">,</span> targetCodec<span style="color:#f92672">,</span> shallowMessageCount<span style="color:#f92672">,</span> validBytesCount<span style="color:#f92672">,</span> monotonic<span style="color:#f92672">,</span> lastOffsetOfFirstBatch<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>② 消息格式规整，即删除无效格式消息或无效字节，根据步骤 <code>①</code> 方法返回的 <code>LogAppendInfo</code> 对象，将<strong>未通过验证</strong>的消息截断</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">trimInvalidBytes</span><span style="color:#f92672">(</span>records<span style="color:#f92672">:</span> MemoryRecords<span style="color:#f92672">,</span> info<span style="color:#f92672">:</span> LogAppendInfo<span style="color:#f92672">):</span> MemoryRecords <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">//写入消息总字节数
</span><span style="color:#75715e"></span>  val validBytes <span style="color:#f92672">=</span> info<span style="color:#f92672">.</span><span style="color:#a6e22e">validBytes</span>
  <span style="color:#a6e22e">if</span> <span style="color:#f92672">(</span>validBytes <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> CorruptRecordException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Cannot append record batch with illegal length $validBytes to &#34;</span> <span style="color:#f92672">+</span>
      s<span style="color:#e6db74">&#34;log for $topicPartition. A possible cause is a corrupted produce request.&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>validBytes <span style="color:#f92672">==</span> records<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeInBytes</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    records
  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// trim invalid bytes
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//超过部分就会被截断
</span><span style="color:#75715e"></span>    val validByteBuffer <span style="color:#f92672">=</span> records<span style="color:#f92672">.</span><span style="color:#a6e22e">buffer</span><span style="color:#f92672">.</span><span style="color:#a6e22e">duplicate</span><span style="color:#f92672">()</span>
    validByteBuffer<span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span><span style="color:#f92672">(</span>validBytes<span style="color:#f92672">)</span>
    MemoryRecords<span style="color:#f92672">.</span><span style="color:#a6e22e">readableRecords</span><span style="color:#f92672">(</span>validByteBuffer<span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>③ 使用当前LEO值作为待写入消息集合的第一条消息位移值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">val offset <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LongRef<span style="color:#f92672">(</span>nextOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span><span style="color:#f92672">)</span>
appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOffset</span> <span style="color:#f92672">=</span> Some<span style="color:#f92672">(</span>offset<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">)</span>
</code></pre></div></li>
<li>
<p>④ 验证消息，保证消息大小不超限</p>
</li>
<li>
<p>⑤ 更新<code>Leader Epoch</code>缓存</p>
</li>
<li>
<p>⑥ 确保消息大小不超限</p>
</li>
<li>
<p>⑦ 执行日志切分，当前日志断剩余容量可能无法容纳新消息集合，因此要创建一个(如果满足需要创建一个新的<code>activeSegment</code>，然后返回当前的activeSegment)</p>
<ul>
<li>
<ol>
<li>当前 <code>activeSegment</code> 的日志大小加上本次待追加的消息集合大小，超过配置的 LogSegment 的最大长度</li>
</ol>
</li>
<li>
<ol start="2">
<li>当前 <code>activeSegment</code> 的寿命超过了配置的 LogSegment 最长<code>存活时间</code></li>
</ol>
</li>
<li>
<ol start="3">
<li>索引文件满了</li>
</ol>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">maybeRoll</span><span style="color:#f92672">(</span>messagesSize<span style="color:#f92672">:</span> Int<span style="color:#f92672">,</span> appendInfo<span style="color:#f92672">:</span> LogAppendInfo<span style="color:#f92672">):</span> LogSegment <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  val segment <span style="color:#f92672">=</span> activeSegment
  val now <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span><span style="color:#a6e22e">milliseconds</span>

  val maxTimestampInMessages <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">maxTimestamp</span>
  val maxOffsetInMessages <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span>

  <span style="color:#75715e">// 在shouldRoll 方法中 判断是否需要创建一个 segment
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>segment<span style="color:#f92672">.</span><span style="color:#a6e22e">shouldRoll</span><span style="color:#f92672">(</span>RollParams<span style="color:#f92672">(</span>config<span style="color:#f92672">,</span> appendInfo<span style="color:#f92672">,</span> messagesSize<span style="color:#f92672">,</span> now<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
      
    appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">firstOffset</span> match <span style="color:#f92672">{</span>
        <span style="color:#75715e">//创建新的activeSegment 调用 roll 方法
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//这里的 activeSegment 其实就是 LogSegment，由于是Kafka 是顺序添加的，所以最后一个LogSegment 就是正在被添加 record 的 Segment 称作为 activeSegment
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">case</span> Some<span style="color:#f92672">(</span>firstOffset<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> roll<span style="color:#f92672">(</span>Some<span style="color:#f92672">(</span>firstOffset<span style="color:#f92672">))</span>
      <span style="color:#66d9ef">case</span> None <span style="color:#f92672">=&gt;</span> roll<span style="color:#f92672">(</span>Some<span style="color:#f92672">(</span>maxOffsetInMessages <span style="color:#f92672">-</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">))</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//通过上面的 shouldRoll 方法得出不需要重新创建activeSegment ，则直接返回
</span><span style="color:#75715e"></span>    segment
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">//是否要重新创建一个 segment
</span><span style="color:#75715e"></span>def <span style="color:#a6e22e">shouldRoll</span><span style="color:#f92672">(</span>rollParams<span style="color:#f92672">:</span> RollParams<span style="color:#f92672">):</span> Boolean <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  val reachedRollMs <span style="color:#f92672">=</span> timeWaitedForRoll<span style="color:#f92672">(</span>rollParams<span style="color:#f92672">.</span><span style="color:#a6e22e">now</span><span style="color:#f92672">,</span> rollParams<span style="color:#f92672">.</span><span style="color:#a6e22e">maxTimestampInMessages</span><span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> rollParams<span style="color:#f92672">.</span><span style="color:#a6e22e">maxSegmentMs</span> <span style="color:#f92672">-</span> rollJitterMs
  size <span style="color:#f92672">&gt;</span> rollParams<span style="color:#f92672">.</span><span style="color:#a6e22e">maxSegmentBytes</span> <span style="color:#f92672">-</span> rollParams<span style="color:#f92672">.</span><span style="color:#a6e22e">messagesSize</span> <span style="color:#f92672">||</span>  <span style="color:#75715e">//条件1 logSegment 满了
</span><span style="color:#75715e"></span>    <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> reachedRollMs<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> <span style="color:#75715e">//条件2 当前activeSegment 的寿命超过了配置的 LogSegment 最长存活时间
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//条件3 索引满了
</span><span style="color:#75715e"></span>    offsetIndex<span style="color:#f92672">.</span><span style="color:#a6e22e">isFull</span> <span style="color:#f92672">||</span> timeIndex<span style="color:#f92672">.</span><span style="color:#a6e22e">isFull</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>canConvertToRelativeOffset<span style="color:#f92672">(</span>rollParams<span style="color:#f92672">.</span><span style="color:#a6e22e">maxOffsetInMessages</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>


<span style="color:#75715e">//这里是roll方法，通过shouldRoll 方法如果满足条件需要创建一个Segment 则会调用此方法
</span><span style="color:#75715e"></span>def <span style="color:#a6e22e">roll</span><span style="color:#f92672">(</span>expectedNextOffset<span style="color:#f92672">:</span> Option<span style="color:#f92672">[</span>Long<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> None<span style="color:#f92672">):</span> LogSegment <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  maybeHandleIOException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Error while rolling log segment for $topicPartition in dir ${dir.getParent}&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    val start <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span><span style="color:#a6e22e">hiResClockMs</span><span style="color:#f92672">()</span>
    lock <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 加锁 多Handler 线程操作会引发线程问题
</span><span style="color:#75715e"></span>      checkIfMemoryMappedBufferClosed<span style="color:#f92672">()</span>
      <span style="color:#75715e">//获取 LEO： LEO是即将要插入的数据 log end offset
</span><span style="color:#75715e"></span>      val newOffset <span style="color:#f92672">=</span> math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>expectedNextOffset<span style="color:#f92672">.</span><span style="color:#a6e22e">getOrElse</span><span style="color:#f92672">(</span>0L<span style="color:#f92672">),</span> logEndOffset<span style="color:#f92672">)</span>
      <span style="color:#75715e">//新日志文件的文件名是 [LEO].log
</span><span style="color:#75715e"></span>      val logFile <span style="color:#f92672">=</span> Log<span style="color:#f92672">.</span><span style="color:#a6e22e">logFile</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> newOffset<span style="color:#f92672">)</span>

      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>segments<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>newOffset<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// segment with the same base offset already exists and loaded
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span> <span style="color:#f92672">==</span> newOffset <span style="color:#f92672">&amp;&amp;</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          <span style="color:#75715e">// We have seen this happen (see KAFKA-6388) after shouldRoll() returns true for an
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// active segment of size zero because of one of the indexes is &#34;full&#34; (due to _maxEntries == 0).
</span><span style="color:#75715e"></span>          warn<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Trying to roll a new log segment with start offset $newOffset &#34;</span> <span style="color:#f92672">+</span>
               s<span style="color:#e6db74">&#34;=max(provided offset = $expectedNextOffset, LEO = $logEndOffset) while it already &#34;</span> <span style="color:#f92672">+</span>
               s<span style="color:#e6db74">&#34;exists and is active with size 0. Size of time index: ${activeSegment.timeIndex.entries},&#34;</span> <span style="color:#f92672">+</span>
               s<span style="color:#e6db74">&#34; size of offset index: ${activeSegment.offsetIndex.entries}.&#34;</span><span style="color:#f92672">)</span>
          removeAndDeleteSegments<span style="color:#f92672">(</span>Seq<span style="color:#f92672">(</span>activeSegment<span style="color:#f92672">),</span> asyncDelete <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> KafkaException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Trying to roll a new log segment for topic partition $topicPartition with start offset $newOffset&#34;</span> <span style="color:#f92672">+</span>
                                   s<span style="color:#e6db74">&#34; =max(provided offset = $expectedNextOffset, LEO = $logEndOffset) while it already exists. Existing &#34;</span> <span style="color:#f92672">+</span>
                                   s<span style="color:#e6db74">&#34;segment is ${segments.get(newOffset)}.&#34;</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>segments<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span> <span style="color:#f92672">&amp;&amp;</span> newOffset <span style="color:#f92672">&lt;</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> KafkaException<span style="color:#f92672">(</span>
          s<span style="color:#e6db74">&#34;Trying to roll a new log segment for topic partition $topicPartition with &#34;</span> <span style="color:#f92672">+</span>
          s<span style="color:#e6db74">&#34;start offset $newOffset =max(provided offset = $expectedNextOffset, LEO = $logEndOffset) lower than start offset of the active segment $activeSegment&#34;</span><span style="color:#f92672">)</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        val offsetIdxFile <span style="color:#f92672">=</span> offsetIndexFile<span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> newOffset<span style="color:#f92672">)</span>
        val timeIdxFile <span style="color:#f92672">=</span> timeIndexFile<span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> newOffset<span style="color:#f92672">)</span>
        val txnIdxFile <span style="color:#f92672">=</span> transactionIndexFile<span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span> newOffset<span style="color:#f92672">)</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>file <span style="color:#f92672">&lt;-</span> List<span style="color:#f92672">(</span>logFile<span style="color:#f92672">,</span> offsetIdxFile<span style="color:#f92672">,</span> timeIdxFile<span style="color:#f92672">,</span> txnIdxFile<span style="color:#f92672">)</span> <span style="color:#66d9ef">if</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">exists</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          warn<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Newly rolled segment file ${file.getAbsolutePath} already exists; deleting it first&#34;</span><span style="color:#f92672">)</span>
          Files<span style="color:#f92672">.</span><span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>

        Option<span style="color:#f92672">(</span>segments<span style="color:#f92672">.</span><span style="color:#a6e22e">lastEntry</span><span style="color:#f92672">).</span><span style="color:#a6e22e">foreach</span><span style="color:#f92672">(</span>_<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">.</span><span style="color:#a6e22e">onBecomeInactiveSegment</span><span style="color:#f92672">())</span>
      <span style="color:#f92672">}</span>

      producerStateManager<span style="color:#f92672">.</span><span style="color:#a6e22e">updateMapEndOffset</span><span style="color:#f92672">(</span>newOffset<span style="color:#f92672">)</span>
      producerStateManager<span style="color:#f92672">.</span><span style="color:#a6e22e">takeSnapshot</span><span style="color:#f92672">()</span>

      <span style="color:#75715e">//新创建的LogSegment
</span><span style="color:#75715e"></span>      val segment <span style="color:#f92672">=</span> LogSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">,</span>
        baseOffset <span style="color:#f92672">=</span> newOffset<span style="color:#f92672">,</span>
        config<span style="color:#f92672">,</span>
        time <span style="color:#f92672">=</span> time<span style="color:#f92672">,</span>
        fileAlreadyExists <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span>
        initFileSize <span style="color:#f92672">=</span> initFileSize<span style="color:#f92672">,</span>
        preallocate <span style="color:#f92672">=</span> config<span style="color:#f92672">.</span><span style="color:#a6e22e">preallocate</span><span style="color:#f92672">)</span>
      <span style="color:#75715e">//将新创建的Segment 添加到 segments 这个跳表中。
</span><span style="color:#75715e"></span>      addSegment<span style="color:#f92672">(</span>segment<span style="color:#f92672">)</span>

      <span style="color:#75715e">//更新 nextOffsetMetadata 这次更新的目的是为了更新其中记录的 activeSegment.baseOffset 和 activeSegment.size ，而 LEO 并不会改变。
</span><span style="color:#75715e"></span>      updateLogEndOffset<span style="color:#f92672">(</span>nextOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span><span style="color:#f92672">)</span>

      <span style="color:#75715e">// schedule an asynchronous flush of the old segment
</span><span style="color:#75715e"></span>      <span style="color:#75715e">//定时任务 执行flush 操作
</span><span style="color:#75715e"></span>      scheduler<span style="color:#f92672">.</span><span style="color:#a6e22e">schedule</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;flush-log&#34;</span><span style="color:#f92672">,</span> <span style="color:#f92672">()</span> <span style="color:#f92672">=&gt;</span> flush<span style="color:#f92672">(</span>newOffset<span style="color:#f92672">),</span> delay <span style="color:#f92672">=</span> 0L<span style="color:#f92672">)</span>

      info<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Rolled new log segment at offset $newOffset in ${time.hiResClockMs() - start} ms.&#34;</span><span style="color:#f92672">)</span>

      segment <span style="color:#75715e">//返回新建的 activeSegment
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>⑧ 验证事务状态</p>
</li>
<li>
<p>⑨：执行真正的消息写入操作，主要调用 <code>LogSegment</code> 对象的 <code>append</code> 方法实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">segment<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>largestOffset <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">lastOffset</span><span style="color:#f92672">,</span>
        largestTimestamp <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">maxTimestamp</span><span style="color:#f92672">,</span>
        shallowOffsetOfMaxTimestamp <span style="color:#f92672">=</span> appendInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">offsetOfMaxTimestamp</span><span style="color:#f92672">,</span>
        records <span style="color:#f92672">=</span> validRecords<span style="color:#f92672">)</span>
</code></pre></div><ul>
<li>调用 <code>LogSegment.append</code> 添加日志，在 <a href="http://www.sirann.cn/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BA%8Clogsegment/">Kafka 日志模块（二）LogSegment</a> 一文中进行分析</li>
</ul>
</li>
<li>
<p>⑩：更新LEO对象，其中，LEO值是消息集合中最后一条消息位移值+1</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> def <span style="color:#a6e22e">updateLogEndOffset</span><span style="color:#f92672">(</span>offset<span style="color:#f92672">:</span> Long<span style="color:#f92672">):</span> Unit <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  nextOffsetMetadata <span style="color:#f92672">=</span> LogOffsetMetadata<span style="color:#f92672">(</span>offset<span style="color:#f92672">,</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">,</span> activeSegment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">)</span>

  <span style="color:#75715e">// Update the high watermark in case it has gotten ahead of the log end offset following a truncation
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// or if a new segment has been rolled and the offset metadata needs to be updated.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>highWatermark <span style="color:#f92672">&gt;=</span> offset<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    updateHighWatermarkMetadata<span style="color:#f92672">(</span>nextOffsetMetadata<span style="color:#f92672">)</span>
  <span style="color:#f92672">}</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">recoveryPoint</span> <span style="color:#f92672">&gt;</span> offset<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">recoveryPoint</span> <span style="color:#f92672">=</span> offset
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>更新 <code>HW</code> 在 <code>2.7.2.2 更新高水位小节</code>中有分析</li>
</ul>
</li>
<li>
<p>⑪：更新事务状态</p>
</li>
<li>
<p>⑫：返回写入结果</p>
</li>
</ul>
<hr>
<h4 id="read">read</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">def <span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>startOffset<span style="color:#f92672">:</span> Long<span style="color:#f92672">,</span>
           maxLength<span style="color:#f92672">:</span> Int<span style="color:#f92672">,</span>
           isolation<span style="color:#f92672">:</span> FetchIsolation<span style="color:#f92672">,</span>
           minOneMessage<span style="color:#f92672">:</span> Boolean<span style="color:#f92672">):</span> FetchDataInfo <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    maybeHandleIOException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Exception while reading from $topicPartition in dir ${dir.getParent}&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      trace<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Reading $maxLength bytes from offset $startOffset of length $size bytes&#34;</span><span style="color:#f92672">)</span>

      val includeAbortedTxns <span style="color:#f92672">=</span> isolation <span style="color:#f92672">==</span> FetchTxnCommitted

      <span style="color:#75715e">// 读取消息时没有使用Monitor锁同步机制，因此这里取巧了，用本地变量的方式把LEO对象保存起来，避免争用（race condition）
</span><span style="color:#75715e"></span>      val endOffsetMetadata <span style="color:#f92672">=</span> nextOffsetMetadata
      val endOffset <span style="color:#f92672">=</span> nextOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span>
      <span style="color:#75715e">//① 如果从LEO处开始读取，那么自然不会返回任何数据，直接返回空消息集合即可
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>startOffset <span style="color:#f92672">==</span> endOffset<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> emptyFetchDataInfo<span style="color:#f92672">(</span>endOffsetMetadata<span style="color:#f92672">,</span> includeAbortedTxns<span style="color:#f92672">)</span>

      <span style="color:#75715e">//② 找到startOffset值所在的日志段对象。注意要使用floorEntry方法
</span><span style="color:#75715e"></span>      var segmentEntry <span style="color:#f92672">=</span> segments<span style="color:#f92672">.</span><span style="color:#a6e22e">floorEntry</span><span style="color:#f92672">(</span>startOffset<span style="color:#f92672">)</span>

      <span style="color:#75715e">// return error on attempt to read beyond the log end offset or read below log start offset
</span><span style="color:#75715e"></span>      <span style="color:#75715e">//③ 满足以下条件之一将被视为消息越界，即你要读取的消息不在该Log对象中：
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 1. 要读取的消息位移超过了LEO值
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 2. 没找到对应的日志段对象
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 3. 要读取的消息在Log Start Offset之下，同样是对外不可见的消息
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>startOffset <span style="color:#f92672">&gt;</span> endOffset <span style="color:#f92672">||</span> segmentEntry <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> startOffset <span style="color:#f92672">&lt;</span> logStartOffset<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> OffsetOutOfRangeException<span style="color:#f92672">(</span>s<span style="color:#e6db74">&#34;Received request for offset $startOffset for partition $topicPartition, &#34;</span> <span style="color:#f92672">+</span>
          s<span style="color:#e6db74">&#34;but we only have log segments in the range $logStartOffset to $endOffset.&#34;</span><span style="color:#f92672">)</span>

      <span style="color:#75715e">//④ 查看一下读取隔离级别设置。
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 普通消费者能够看到[Log Start Offset, LEO)之间的消息
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 事务型消费者只能看到[Log Start Offset, Log Stable Offset]之间的消息。Log Stable Offset(LSO)是比LEO值小的位移值，为Kafka事务使用
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// Follower副本消费者能够看到[Log Start Offset，高水位值]之间的消息
</span><span style="color:#75715e"></span>      val maxOffsetMetadata <span style="color:#f92672">=</span> isolation match <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">case</span> FetchLogEnd <span style="color:#f92672">=&gt;</span> nextOffsetMetadata
        <span style="color:#66d9ef">case</span> FetchHighWatermark <span style="color:#f92672">=&gt;</span> fetchHighWatermarkMetadata
        <span style="color:#66d9ef">case</span> FetchTxnCommitted <span style="color:#f92672">=&gt;</span> fetchLastStableOffsetMetadata
      <span style="color:#f92672">}</span>

      <span style="color:#75715e">//⑤ 如果要读取的起始位置超过了能读取的最大位置，返回空的消息集合，因为没法读取任何消息
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>startOffset <span style="color:#f92672">&gt;</span> maxOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">messageOffset</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        val startOffsetMetadata <span style="color:#f92672">=</span> convertToOffsetMetadataOrThrow<span style="color:#f92672">(</span>startOffset<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> emptyFetchDataInfo<span style="color:#f92672">(</span>startOffsetMetadata<span style="color:#f92672">,</span> includeAbortedTxns<span style="color:#f92672">)</span>
      <span style="color:#f92672">}</span>

      <span style="color:#75715e">//⑥ 开始遍历日志段对象，直到读出东西来或者读到日志末尾
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>segmentEntry <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        val segment <span style="color:#f92672">=</span> segmentEntry<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span>

        val maxPosition <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
          <span style="color:#75715e">// Use the max offset position if it is on this segment; otherwise, the segment size is the limit.
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>maxOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">segmentBaseOffset</span> <span style="color:#f92672">==</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">baseOffset</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            maxOffsetMetadata<span style="color:#f92672">.</span><span style="color:#a6e22e">relativePositionInSegment</span>
          <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            segment<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span>
          <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">//⑦ 调用Segment.read方法执行真正的读取消息操作
</span><span style="color:#75715e"></span>        val fetchInfo <span style="color:#f92672">=</span> segment<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>startOffset<span style="color:#f92672">,</span> maxLength<span style="color:#f92672">,</span> maxPosition<span style="color:#f92672">,</span> minOneMessage<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fetchInfo <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 如果没有返回任何消息，去下一个日志段对象试试
</span><span style="color:#75715e"></span>          segmentEntry <span style="color:#f92672">=</span> segments<span style="color:#f92672">.</span><span style="color:#a6e22e">higherEntry</span><span style="color:#f92672">(</span>segmentEntry<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 否则返回
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>includeAbortedTxns<span style="color:#f92672">)</span>
            addAbortedTransactions<span style="color:#f92672">(</span>startOffset<span style="color:#f92672">,</span> segmentEntry<span style="color:#f92672">,</span> fetchInfo<span style="color:#f92672">)</span>
          <span style="color:#66d9ef">else</span>
            fetchInfo
        <span style="color:#f92672">}</span>
      <span style="color:#f92672">}</span>

      <span style="color:#75715e">//⑧ 已经读到日志末尾还是没有数据返回，只能返回空消息集合
</span><span style="color:#75715e"></span>      FetchDataInfo<span style="color:#f92672">(</span>nextOffsetMetadata<span style="color:#f92672">,</span> MemoryRecords<span style="color:#f92672">.</span><span style="color:#a6e22e">EMPTY</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p><code>startOffset</code> 参数：开始读取消息的offset位置</p>
</li>
<li>
<p><code>maxLength</code> 参数：最大读取多少字节</p>
</li>
<li>
<p><code>isolation</code> 参数：提取隔离，控制我们允许读取的最大偏移量，它是 <code>FetchIsolation</code> 有三个实现类如下：
<img src="http://img.sirann.cn//siran/20200502220013.png" alt=""></p>
<ul>
<li><code>FetchHighWatermark</code>： 只能消费到 HW 的位置</li>
<li><code>FetchLogEnd</code>： 能消费到LEO的位置</li>
<li><code>FetchTxnCommitted</code>： 只能消费到事务提交的offset的位置。</li>
</ul>
</li>
<li>
<p><code>minOneMessage</code> 参数：拉取的消息如果超过 <code>maxLength</code> 设置的值，是否要返回，true是返回。</p>
</li>
<li>
<p>① 如果从LEO处开始读取，那么自然不会返回任何数据，直接返回空消息集合即可</p>
</li>
<li>
<p>② 找到startOffset值所在的日志段对象。注意要使用floorEntry方法</p>
</li>
<li>
<p>③ 满足以下条件之一将被视为消息越界，即你要读取的消息不在该Log对象中：</p>
<ol>
<li>要读取的消息位移超过了LEO值</li>
<li>没找到对应的日志段对象</li>
<li>要读取的消息在Log Start Offset之下，同样是对外不可见的消息</li>
</ol>
</li>
<li>
<p>④ 查看一下读取隔离级别设置。根据 <code>isolation</code> 参数</p>
</li>
<li>
<p>⑤ 如果要读取的起始位置超过了能读取的最大位置，返回空的消息集合，因为没法读取任何消息</p>
</li>
<li>
<p>⑥ 开始遍历日志段对象，直到读出东西来或者读到日志末尾</p>
</li>
<li>
<p>⑦ 调用<code>Segment#read</code>方法执行真正的读取消息操作</p>
</li>
<li>
<p>⑧ 已经读到日志末尾还是没有数据返回，只能返回空消息集合</p>
</li>
</ul>
<hr>
<p>由于篇幅问题，在 <a href="http://localhost:1313/blog/%E8%B7%B3%E8%A1%A8%E5%9C%A8-kafka-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/">跳表在 Kafka 中的实现</a>  一文中会详细分析<code>跳表</code>在Kafka中的使用。</p>
<hr>
<p><strong>参考：</strong></p>
<p>Kafka-2.5.0 源码</p>
<p><a href="https://kafka.apache.org/">Kafka 官网</a></p>
<p>《Apache Kafka源码剖析》</p>
<p>《深入理解Kafka：核心设计与实践》</p>

                        </div>
                        
                        
                        
                        
                        <ul class="pager blog-pager">
                        
                        <li class="previous">
                        <a href="/blog/kafka-%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83-log-%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98/" data-toggle="tooltip" data-placement="top" title="Kafka 源码环境 Log 输出问题">&larr; 上一篇</a>
                        </li>
                         
                        <li class="next">
                        <a href="/blog/skywalking%E4%B8%80opentracing/" data-toggle="tooltip" data-placement="top" title="Skywalking（一）OpenTracing">下一篇 &rarr;</a>
                        </li>
                        
                        </ul>
                        
                        
                        


                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        <div class="panel panel-default sidebar-menu">
     
    <div class="panel-heading">
     <h3 class="panel-title">相关文章</h3>
    </div>
    <div class="panel-body">
     <ul class="nav nav-pills nav-stacked">
        
        <li><a href="/blog/kafka-%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83-log-%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98/"><i class="fa fa-link"></i>Kafka 源码环境 Log 输出问题</a></li>
         
        <li><a href="/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%89kafka-server-start.sh/"><i class="fa fa-link"></i>Kafka 服务端（三）kafka-server-start.sh</a></li>
         
        <li><a href="/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%8Ckafkaapis/"><i class="fa fa-link"></i>Kafka 服务端（二）KafkaApis</a></li>
         
        <li><a href="/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E7%BD%91%E7%BB%9C%E5%B1%82/"><i class="fa fa-link"></i>Kafka 服务端（一）网络层</a></li>
         
        <li><a href="/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%89sender-%E7%BA%BF%E7%A8%8B/"><i class="fa fa-link"></i>Kafka 生产者（三）Sender 线程</a></li>
         
     </ul>
    </div>
     
</div>





<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">分类</h3>
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            <li><a href="/categories/gateway"><i class="fa fa-navicon"></i>gateway (4)</a>
            </li>
            
            <li><a href="/categories/guava"><i class="fa fa-navicon"></i>guava (1)</a>
            </li>
            
            <li><a href="/categories/java"><i class="fa fa-navicon"></i>java (7)</a>
            </li>
            
            <li><a href="/categories/jvm"><i class="fa fa-navicon"></i>jvm (2)</a>
            </li>
            
            <li><a href="/categories/resilience4j"><i class="fa fa-navicon"></i>resilience4j (1)</a>
            </li>
            
            <li><a href="/categories/skywalking"><i class="fa fa-navicon"></i>skywalking (2)</a>
            </li>
            
            <li><a href="/categories/spring"><i class="fa fa-navicon"></i>spring (2)</a>
            </li>
            
            <li><a href="/categories/%e5%88%86%e5%b8%83%e5%bc%8f"><i class="fa fa-navicon"></i>分布式 (3)</a>
            </li>
            
            <li><a href="/categories/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b"><i class="fa fa-navicon"></i>并发编程 (17)</a>
            </li>
            
            <li><a href="/categories/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97"><i class="fa fa-navicon"></i>消息队列 (22)</a>
            </li>
            
            <li><a href="/categories/%e7%ae%97%e6%b3%95"><i class="fa fa-navicon"></i>算法 (3)</a>
            </li>
            
            <li><a href="/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba"><i class="fa fa-navicon"></i>计算机 (8)</a>
            </li>
            
        </ul>
    </div>
</div>







                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4>关于我</h4>

            <p>想当程序员的程序员</p>

            <hr class="hidden-md hidden-lg hidden-sm">

            <h4>友情连接</h4>

            <p>&nbsp;<a href="https://www.theyann.xyz:8123/home.html"> theyann</a></p>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/kafka-controller-%E6%A8%A1%E5%9D%97%E4%B8%80%E6%A6%82%E8%BF%B0/">
                            
                            <img src="/img/blog/kafka/kafkaLogo.jpg" class="img-responsive" alt="Kafka Controller 模块（一）概述">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/kafka-controller-%E6%A8%A1%E5%9D%97%E4%B8%80%E6%A6%82%E8%BF%B0/">Kafka Controller 模块（一）概述</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/kafka-%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%9D%97-replicamanager/">
                            
                            <img src="/img/blog/kafka/kafkaLogo.jpg" class="img-responsive" alt="Kafka 副本模块 ReplicaManager">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/kafka-%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%9D%97-replicamanager/">Kafka 副本模块 ReplicaManager</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/kafka-%E6%97%B6%E9%97%B4%E8%BD%AE-java-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0/">
                            
                            <img src="/img/blog/banners/0069RVTdgy1fu1i0mvc5yj31ji15ob2b.jpg" class="img-responsive" alt="Kafka 时间轮 Java 版本实现">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/kafka-%E6%97%B6%E9%97%B4%E8%BD%AE-java-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0/">Kafka 时间轮 Java 版本实现</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6 ">

            <h4>联系</h4>

            <p>个人微信</br>请备注姓名-公司信息</p><p><img src="/img/1.png"></p>
      

            <a href="/contact" class="btn btn-small btn-template-main">跳到联系页面</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020, siran all rights reserved.</p>
            
            
            <p class="pull-left">&nbsp;<a href="http://www.beian.miit.gov.cn/"> 苏ICP备20005919号</a></p>
            
            <p class="pull-right">
                模板来自 <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
                

                移植到 Hugo 来自 <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    <script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>
<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>

<script src="/js/prism.js"></script>


<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>


  </body>
</html>
