<!DOCTYPE html>
<html lang="zh">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>计算机之文件系统 · 技术分享</title>
  <meta name="author" content="Siran Yao(姚毅晨)" />

  
  <meta name="keywords" content="计算机">
  

  <meta name="generator" content="Hugo 0.65.2" />

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
  <link href="/css/style.default.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/search.css" />

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/1587537069710-removebg-preview.png" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/1587537069710-removebg-preview.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">
  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="拳拳到肉">

  
  <link rel="stylesheet" href="/css/prism.css" />

  
  <meta property="og:title" content="计算机之文件系统" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F//" />
  <meta property="og:image" content="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" />
  <meta property="og:image:alt" content="ServiceMesher Logo" />

  
  <meta name="description" content="所有的应用程序都需要存储和检索信息。当进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受虚拟地址空间大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了">
  <meta property="og:description" content="所有的应用程序都需要存储和检索信息。当进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受虚拟地址空间大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了">
  <meta name="twitter:description" content="所有的应用程序都需要存储和检索信息。当进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受虚拟地址空间大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了">
  <meta property="og:description" content="所有的应用程序都需要存储和检索信息。当进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受虚拟地址空间大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了" />

  
  <meta name="referrer" content="never">

  
  
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?154337f0d95f0b110f98c1d5d7038895";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>


  
  

</head>


  <body>



    <div id="all">

        <header>

          <div class="navbar-affixed-top" data-spy="affix" data-offset-top="200">

    <div class="navbar navbar-default yamm" role="navigation" id="navbar">

        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="计算机之文件系统 logo" class="hidden-xs hidden-sm">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="计算机之文件系统 logo" class="visible-xs visible-sm">
                    <span class="sr-only">计算机之文件系统 - 跳到主页</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only">切换导航</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="计算机之文件系统 logo" class="hidden-xs hidden-sm">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="计算机之文件系统 logo" class="visible-xs visible-sm">
                    <span class="sr-only">计算机之文件系统 - 跳到主页</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                        <span class="sr-only">切换导航</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="计算机之文件系统 logo" class="hidden-xs hidden-sm">
                    <img src="/img/6a04b428gy1fzy78qjmomg206o06ojsg.gif" alt="计算机之文件系统 logo" class="visible-xs visible-sm">
                    <span class="sr-only">计算机之文件系统 - 跳到主页</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                        <span class="sr-only">切换导航</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">文档 <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        <li><a href="https://www.elastic.co/">Elastic 官网</a></li>
                      
                        <li><a href="http://pulsar.apache.org/en/">Pulsar官网</a></li>
                      
                    </ul>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">联系我</a>
                    
                  </li>
                  
                  
                    <li>
                        <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
                        <span class="hidden-sm hidden-md hidden-lg">搜索</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
                    </a>
                    </li>
                  
                </ul>
            </div>
            

        </div>
    </div>
    

</div>




<div id="modalSearch" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">博客搜索</h4>
      </div>
      <div class="modal-body">
          
<div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="输入文章标题或摘要" name="search" autocomplete="off" autofocus="autofocus"/>
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>

<script>
var client = algoliasearch("X4YB3WOBNV", "d2134c5a8d250e6d3246594240c45201");
var index = client.initIndex("servicemesher");

autocomplete('#aa-search-input',
{ hint: false}, {
    source: autocomplete.sources.hits(index, {hitsPerPage: 5}),
    
    displayKey: 'name',
    
    templates: {
        
        suggestion: function(suggestion) {
            baseURL=""
            baseURL=baseURL.substring(0,baseURL.length-1)
            return '<span>' + '<a href="' + baseURL + suggestion.url+ '">' +
                suggestion._highlightResult.title.value + '</a></span>'+
                '<span>'+suggestion._highlightResult.summary.value+'</span>';
        }
    }
});
</script>

      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
      </div>
    </div>
  </div>
</div>


        </header>

        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>计算机之文件系统</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">
                        <div class="well">
                            <div class="author-category">
                            <i class="fa fa-calendar-o">
                            2020年3月17日
                            </i>
                            |
                            
                            作者 Siran
                            
                            
                            
                            |
                            8900字 | 阅读大约需要18分钟
                            </div>
                            
                            
                            <div class="author-category">
                            
                            
                            归档于 <a href="/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba">计算机</a>
                            
                            |
                            
                            
                            
                            标签
                            
                            <a style="text-transform:capitalize" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"><i>#计算机</i></a>
                            
                            </div>
                            
                            
                        </div>
                        <div id="post-content">
                          <p>所有的应用程序都需要存储和检索信息。当进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受<code>虚拟地址</code>空间大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了。</p>
<p>在进程的<code>地址空间</code>上保存信息的第二个问题是，当进程终止时信息会丢失。对于一些应用程序（例如数据库），信息会长久保留。<strong>在这些进程终止时，相关的信息应该保留下来，是不能够丢失的。甚至是，即便这些应用程序崩溃后，这些信息也应该保留下来。</strong></p>
<p>第三个问题是，通常需要很多进程在同一时刻访问这些信息。<strong>解决这种问题的方式是把这些信息单独保留在各自的进程中。</strong></p>
<p>因此，<code>长久存储</code>的信息我们有三个基本需求：</p>
<ul>
<li>必须要有可能存储的大量的信息</li>
<li>信息必须能够在进程终止时保留</li>
<li>必须能够使多个进程同时访问有关信息</li>
</ul>
<p><code>磁盘(Magnetic disk) </code>一直是用来长久保存信息的设备。近些年来，固态硬盘逐渐流行起来。</p>
<p><code>固态硬盘</code>不仅没有易损坏的移动部件，而且能够提供快速的<code>随机访问</code>。相比而言，虽然磁带和光盘也被广泛使用，但是它们的性能相对较差，通常应用于备份。我们会在后面探讨磁盘，现在姑且把磁盘当作一种大小固定块的线性序列好了，并且支持如下操作</p>
<ul>
<li>读块 k</li>
<li>写块 k</li>
</ul>
<p>然而，磁盘还有一些不便于实现的操作，特别是在有很多程序或者多用户使用着的大型系统上（如服务器）。在这种情况下，很容易产生一些问题，例如：</p>
<ul>
<li>你如何找到这些信息？</li>
<li>你如何保证一个用户不会读取另外一个用户的数据？</li>
<li>你怎么知道哪些块是空闲的？</li>
</ul>
<hr>
<h3 id="文件">文件</h3>
<p>像前面两篇文章介绍的那样，操作系统对处理器建立了进程的抽象，以及对物理存储器建立进程(虚拟)地址空间那样，我们用一个新的抽象——<code>文件</code>。<strong>进程和线程的抽象、地址空间和文件都是操作系统的重要概念。</strong></p>
<p><code>文件</code>是由进程创建的逻辑信息单元。一个磁盘会包含几千甚至几百万个文件，每个文件是独立于其他文件的。事实上，如果你能把每个文件都看作一个独立的地址空间，那么你就可以真正理解文件的概念了。</p>
<p>进程能够读取已经存在的文件，并在需要时重新创建他们。存储在文件中的信息必须是<code>持久的</code>，<strong>这也就是说，不会因为进程的创建和终止而受影响。一个文件只能在当用户明确删除的时候才能消失。尽管读取和写入都是最基本的操作，但还有许多其他操作</strong>，我们将在下面介绍其中的一些。</p>
<p>文件由操作系统进行管理，有关文件的<strong>构造、命名、访问、使用、保护、实现和管理方式</strong>都是操作系统设计的主要内容。从总体上看，操作系统中处理文件的部分称为 <code>文件系统(file system)</code>，这就是我们所讨论的。</p>
<p>从用户角度来说，用户通常会关心文件是由什么组成的，如何给文件进行命名，如何保护文件，以及可以对文件进行哪些操作等等。尽管是用链表还是用位图记录内存空闲区并不是用户所关心的主题，而这些对系统设计人员来说至关重要。下面我们就来探讨一下这些主题</p>
<hr>
<h4 id="文件命名">文件命名</h4>
<p>文件是一种抽象机制，它提供了一种在磁盘上保存信息而且方便以后读取的方法。这种方法可以使用户不必了解存储信息的方法、位置和实际磁盘工作方式等有关细节。
可能任何一种机制最重要的特性就是<code>管理对象的命名方式</code>。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用<code>名称访问该文件</code>。</p>
<p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 <code>1 - 8</code> 个字母的字符串作为合法文件名。</p>
<p>某些文件区分大小写字母，而大多数则不区分。<code>UNIX</code> 属于第一类；历史悠久的 <code>MS-DOS</code> 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；
因此，UNIX 系统会有三种不同的命名文件：<code>maria、Maria、MARIA</code> 。在 MS-DOS ，所有这些命名都属于相同的文件。
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/640.jpeg" alt=""></p>
<p>Windows 95 和 Windows 98 都使用了<code> MS-DOS 文件系统</code>，叫做 <code>FAT-16</code>，因此继承了它的一些特征，例如有关文件名的构造方法。Windows 98 引入了对 FAT-16 的一些扩展，从而导致了 <code>FAT-32</code> 的生成，但是这两者很相似。</p>
<p>另外，<strong>Windows NT，Windows 2000，Windows XP，Windows Vista，Windows 7 和 Windows 8 都支持 FAT 文件系统</strong>，这种文件系统有些过时。然而，这些较新的操作系统还具有更高级的<code>本机文件系统(NTFS)</code>，有不同的特性，那就是基于 <code>Unicode</code> 编码的文件名。事实上，Windows 8 还配备了另一种文件系统，简称 <code>ReFS(Resilient File System)</code>，但这个文件系统一般应用于 Windows 8 的服务器版本。</p>
<p>下面除非我们特殊声明，否则我们在提到 MS-DOS 和 FAT 文件系统的时候，所指的就是 Windows 的 FAT-16 和 FAT-32。这里要说一下，有一种类似 FAT 的新型文件系统，叫做 <code>exFAT</code>。<strong>它是微软公司对闪存和大文件系统开发的一种优化的 FAT 32 扩展版本。ExFAT 是现在微软唯一能够满足 OS X读写操作的文件系统。</strong></p>
<p>许多操作系统支持两部分的文件名，它们之间用 <code>. </code>分隔开，比如文件名 <code>prog.c</code>。原点后面的文件称为 <code>文件扩展名(file extension)</code> ，文件扩展名通常表示文件的一些信息。<strong>例如在 MS-DOS 中，文件名是 1 - 8 个字符，加上 1 - 3 个字符的可选扩展名组成</strong>。在 <code>UNIX</code> 中，如果有扩展名，那么扩展名的长度将由用户来决定，一个文件甚至可以包括两个或更多的扩展名，例如 <strong>homepage.html.zip，html 表示一个 web 网页而 .zip 表示文件homepage.html 已经采用 zip 程序压缩完成</strong>。一些常用的文件扩展名以及含义如下图所示
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/641.jpeg" alt="">
在 <code>UNIX</code> 系统中，<strong>文件扩展名只是一种约定</strong>，操作系统并不强制采用。</p>
<p>名为 file.txt 的文件是文本文件，这个文件名更多的是<code>提醒</code>所有者，而不是给计算机传递信息。但是另一方面，<strong>C 编译器可能要求它编译的文件以.c 结尾，否则它会拒绝编译。然而，操作系统并不关心这一点。</strong></p>
<p>对于可以处理多种类型的程序，约定就显得及其有用。例如 <strong>C 编译器可以编译、链接多种文件，包括 C 文件和汇编语言文件。这时扩展名就很有必要，编译器利用它们区分哪些是 C 文件，哪些是汇编文件，哪些是其他文件。因此，扩展名对于编译器判断哪些是 C 文件，哪些是汇编文件以及哪些是其他文件变得至关重要</strong>。</p>
<p>与 UNIX 相反，<code>Windows</code> 就会关注扩展名并对<code>扩展名</code>赋予了新的含义。用户(或进程) 可以在操作系统中注册扩展名，并且规定哪个程序能够拥有扩展名。当用户双击某个文件名时，拥有该文件名的程序就启动并运行文件。<strong>例如，双击 file.docx 启动了 Word 程序，并以 file.docx 作为初始文件。</strong></p>
<hr>
<h4 id="文件结构">文件结构</h4>
<p>文件的构造有多种方式。下图列出了常用的三种构造方式
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/642.jpeg" alt=""></p>
<ul>
<li>
<p>上图中的 a 是一种<code>无结构的字节序列</code>，操作系统不关心序列的内容是什么，操作系统能看到的就是<code>字节(bytes)</code>。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。
把文件看成字节序列提供了最大的灵活性。用户程序可以向文件中写任何内容，并且可以通过任何方便的形式命名。操作系统不会为为用户写入内容提供帮助，当然也不会干扰阻塞你。对于想做特殊操作的用户来说，后者是十分重要的。所有的 UNIX 版本（包括 Linux 和 OS X）和 Windows 都使用这种文件模型。</p>
</li>
<li>
<p>图 b <code>记录序列</code>表示在文件结构上的第一步改进。在这个模型中，文件是具有固定长度记录的序列，<strong>每个记录都有其内部结构</strong>。把文件作为记录序列的核心思想是：<strong>读操作返回一个记录，而写操作重写或者追加一个记录。</strong></p>
</li>
<li>
<p>第三种文件结构如上图 c 所示。在这种组织结构中，<code>文件由一颗记录树构成</code>，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个<code>key </code>字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。
在记录树的结构中，可以取出下一个记录，但是最关键的还是根据 key 搜索指定的记录。如上图 c 所示，用户可以读出指定的 pony 记录，而不必关心记录在文件中的确切位置。用户也可以在文件中添加新的记录。但是用户不能决定添加到何处位置，添加到何处位置是由<code>操作系统</code>决定的。</p>
</li>
</ul>
<hr>
<h4 id="文件类型">文件类型</h4>
<p>很多操作系统支持<code>多种</code>文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有<code>常规的文件</code>和<code>目录</code>。除此之外，UNIX 还具有<code>字符特殊文件(character special file)</code> 和 <code>块特殊文件(block special file)</code></p>
<ul>
<li><code>常规的文件</code>：是包含有用户信息的文件，在上图中的所有文件都是普通文件</li>
<li><code>目录</code>：是管理文件结构的系统文件</li>
<li><code>字符特殊文件</code>：和输入/输出有关，用于串行I/O类设备，如终端、打印机、网络等。</li>
<li><code>块特殊文件</code>：用于磁盘类设备</li>
</ul>
<p>常规文件一般分为 <code>ASCII 码文件</code>或者<code>二进制文件</code>。ASCII 码文件由<code>文本</code>组成。<strong>在一些系统中，每行都会用回车符结束（ASCII码是13，控制字符 CR，转义字符\r。），另外一些则会使用换行符（ASCII码是10，控制字符LF，转义字符\n）。一些系统（比如 Windows）两者都会使用。</strong></p>
<p>ASCII 文件的优点在于<code>显示</code> 和 <code>打印</code>，还可以用任何文本编辑器进行编辑。进一步来说，<strong>如果许多应用程序使用 ASCII 码作为输入和输出，那么很容易就能够把多个程序连接起来，一个程序的输出可能是另一个程序的输入，就像管道一样。</strong></p>
<p>其他与 ASCII 不同的是<code>二进制文件</code>。打印出来的二进制文件是无法理解的。下面是一个二进制文件的格式，它取自早期的 UNIX 。尽管从技术上来看这个文件只是<code>字节序列</code>，但是操作系统只有在文件格式正确的情况下才会执行。
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/643.jpeg" alt="">
这个文件有五个段：<code>文件头、正文、数据、重定位位和符号表</code>。文件头以 <code>魔数(magic number) </code>为开始，<strong>表明这个文件是一个可执行文件（以防止意外执行非此格式的文件）</strong>。然后是文件各个部分的大小，开始执行的标志以及一些标志位。程序本身的正文和数据在文件头后面，他们被加载到内存中或者重定位会根据<code>重定位位</code>进行判断。符号表则用于<code>调试</code>。</p>
<p>二进制文件的另外一种形式是<code>存档文件</code>，它由已编译但没有链接的库过程（模块）组合而成。每个文件都以<code>模块头</code>开始，<strong>其中记录了名称、创建日期、所有者、保护码和文件大小。和可执行文件一样，模块头也都是二进制数，将它们复制到打印机将会产生乱码。</strong></p>
<p>所有的操作系统必须至少能够识别一种文件类型：<code>它自己的可执行文件</code>。以前的 TOPS-20 系统（用于DECsystem 20）甚至要检查要执行的任何文件的创建时间，为了定位资源文件来检查自动文件创建后是否被修改过。如果被修改过了，那么就会自动编译文件。在 UNIX 中，就是在 shell 中嵌入 make 程序。此时操作系统要求用户必须采用固定的文件扩展名，从而确定哪个源程序生成哪个二进制文件。</p>
<blockquote>
<p><code>make 程序是一个自动编译的工具</code>，它通过读取称为 Makefiles 的文件来自动从源代码构建可执行程序和库，该文件指定了如何导出目标程序。尽管集成开发环境和特定语言的编译器功能也可以用于管理构建过程，但 Make 仍被广泛使用，尤其是在 Unix 和类似 Unix 的操作系统中使用。</p>
</blockquote>
<p>当程序从文件中读写数据时，请求会转到<code>内核处理程序(kernel driver)</code>。<strong>如果文件是常规文件，则数据由文件系统驱动程序处理，并且通常存储在磁盘或其他存储介质上的某块区域中，从文件中读取的数据就是之前在该位置写入的数据。</strong></p>
<p>当数据读取或写入到设备文件时，请求会被设备驱动程序处理。每个设备文件都有一个关联的编号，该编号标示要使用的设备驱动程序。设备处理数据的工作是它自己的事儿。</p>
<ul>
<li>
<p><code>块设备</code> 也叫做块特殊文件，它的行为通常与普通文件相似：它们是字节数组，并且在给定位置读取的值是最后写入该位置的值。来自块设备的数据可以缓存在内存中，并从缓存中读取；写入可以被缓冲。块设备通常是可搜索的，块设备的概念是，相应的硬件可以一次读取或者写入整个块，例如磁盘上的一个扇区</p>
</li>
<li>
<p><code>字符设备</code> 也称为字符特殊文件，它的行为类似于管道、串行端口。将字节写入字符设备可能会导致它在屏幕上显示，在串行端口上输出，转换为声音。</p>
</li>
</ul>
<p><code>目录(Directories)</code> 是管理文件系统结构的系统文件。它是用于在计算机上存储文件的位置。目录位于<code>分层文件系统中</code>，例如 Linux，MS-DOS 和 UNIX。
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/644.jpeg" alt="">
它显示所有本地和子目录（例如，cdn 目录中的 big 目录）。当前目录是 C 盘驱动器的<code>根目录</code>。之所以称为根目录，是因为该目录下没有任何内容，而其他目录都在该目录下<code>分支</code>。</p>
<hr>
<h4 id="文件访问">文件访问</h4>
<p>早期的操作系统只有一种访问方式：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照<code>顺序</code>读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p>
<p>在使用磁盘来存储文件时，可以<code>不按照顺序</code>读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p>
<p>随机访问文件对许多应用程序来说都必不可少，<strong>例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</strong></p>
<p>有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 <code>read</code> 从头开始读取。另一种是用一个特殊的 <code>seek</code> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。<strong>UNIX 和 Windows  使用的是后面一种方式。</strong></p>
<hr>
<h4 id="文件属性">文件属性</h4>
<p>文件包括<code>文件名</code>和<code>数据</code>。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件**创建的日期和时间、文件大小。**我们可以称这些为<code>文件的属性(attributes)</code>。
有些人也喜欢把它们称作 <code>元数据(metadata)</code>。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：<code>设置(set)</code> 和 <code>清除(clear)</code>。下面是一些常用的属性
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/645.jpeg" alt=""></p>
<p>没有一个系统能够同时具有上面所有的属性，但每个属性都在某个系统中采用。</p>
<p>前面四个属性（保护，口令，创建者，所有者）与文件保护有关，它们指出了谁可以访问这个文件，谁不能访问这个文件。</p>
<ul>
<li><code>保护（File Protection）</code>：用于保护计算机上有价值数据的方法。文件保护是通过<code>密码保护文件</code>或者仅仅向特定用户或组提供<code>权限</code>来实现。</li>
</ul>
<p>在一些系统中，用户必须给出口令才能访问文件。<code>标志(flags)</code>是一些位或者短属性能够控制或者允许特定属性。</p>
<ul>
<li>
<p><code>隐藏文件位(hidden flag)</code>表示该文件不在文件列表中出现。</p>
</li>
<li>
<p><code>存档标志位(archive flag)</code>用于记录文件是否备份过，由备份程序清除该标志位；若文件被修改，操作系统则设置该标志位。用这种方法，备份程序可以知道哪些文件需要备份。</p>
</li>
<li>
<p><code>临时标志位(temporary flag)</code> 允许文件被标记为是否允许自动删除当进程终止时。</p>
</li>
<li>
<p><code>记录长度(record-length)</code>、<code>键的位置(key-position)</code>和<code>键的长度(key-length)</code>等字段只能出现在用关键字查找记录的文件中。它们提供了查找关键字所需要的信息。</p>
</li>
</ul>
<p>不同的时间字段记录了<strong>文件的创建时间、最近一次访问时间以及最后一次修改时间，它们的作用不同</strong>。例如，目标文件生成后被修改的源文件需要重新编译生成目标文件。这些字段提供了必要的信息。</p>
<p>当前大小字段指出了当前的文件大小，一些旧的大型机操作系统要求在创建文件时指定文件最大值，以便让操作系统提前保留最大存储值。但是一些服务器和个人计算机却不用设置此功能。</p>
<hr>
<h4 id="文件操作">文件操作</h4>
<p>使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</p>
<ul>
<li>
<p><code>Create</code>，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</p>
</li>
<li>
<p><code>Delete</code>，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</p>
</li>
<li>
<p><code>Open</code>，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</p>
</li>
<li>
<p><code>Close</code>，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一块，即使这个块空间内部还不满。</p>
</li>
<li>
<p><code>Read</code>，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</p>
</li>
<li>
<p><code>Write</code>，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</p>
</li>
<li>
<p><code>append</code>，使用 append 只能向文件末尾添加数据。</p>
</li>
<li>
<p><code>seek</code>，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</p>
</li>
<li>
<p><code>get attributes</code>，进程运行时通常需要读取文件属性。</p>
</li>
<li>
<p><code>set attributes</code>，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</p>
</li>
<li>
<p><code>rename</code>，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</p>
</li>
</ul>
<hr>
<h3 id="目录">目录</h3>
<p>文件系统通常提供<code>目录(directories)</code> 或者 <code>文件夹(folders)</code> 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</p>
<hr>
<h4 id="一级目录系统">一级目录系统</h4>
<p>目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为<code>根目录(root directory)</code>，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/646.jpeg" alt=""></p>
<p>该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</p>
<hr>
<h4 id="层次目录系统">层次目录系统</h4>
<p>对于简单的应用而言，一般都用单层目录方式，但是这种组织形式<strong>并不适合于现代计算机</strong>，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了<strong>层次目录系统(Hierarchical Directory Systems)</strong>，也称为<code>目录树</code>。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/647.jpeg" alt="">
根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了子目录。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的</p>
<hr>
<h4 id="路径名">路径名</h4>
<p>当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个<code>绝对路径名(absolute path name)</code>，它由根目录到文件的路径组成。举个例子，<code>/usr/ast/mailbox</code> 意味着根目录包含一个子目录<code>usr</code>，usr 下面包含了一个 <code>mailbox</code>。绝对路径名总是以 <code>/</code> 开头，并且是唯一的。在UNIX中，路径的组件由/分隔。在Windows中，分隔符为<code>\</code>。在 MULTICS 中，它是<code>&gt;</code>。因此，在这三个系统中，相同的路径名将被编写如下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Windows <span style="color:#960050;background-color:#1e0010">\</span>usr<span style="color:#960050;background-color:#1e0010">\</span>ast<span style="color:#960050;background-color:#1e0010">\</span>mailbox
UNIX <span style="color:#f92672">/</span>usr<span style="color:#f92672">/</span>ast<span style="color:#f92672">/</span>mailbox
MULTICS <span style="color:#f92672">&gt;</span>usr<span style="color:#f92672">&gt;</span>ast<span style="color:#f92672">&gt;</span>mailbox
</code></pre></div><p>不论使用哪种方式，如果路径名的<code>第一个字符是分隔符</code>，那就是<code>绝对路径。</code></p>
<p>另外一种指定文件名的方法是 <code>相对路径名(relative path name)</code>。它常常和 <code>工作目录(working directory)</code> （也称作 <code>当前目录(current directory)</code>）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 <code>/usr/ast</code>，那么绝对路径 <code>/usr/ast/mailbox</code>可以直接使用 <code>mailbox</code> 来引用。也就是说，如果工作目录是 /usr/ast，则 UNIX 命令</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">cp <span style="color:#f92672">/</span>usr<span style="color:#f92672">/</span>ast<span style="color:#f92672">/</span>mailbox  <span style="color:#f92672">/</span>usr<span style="color:#f92672">/</span>ast<span style="color:#f92672">/</span>mailbox<span style="color:#f92672">.</span><span style="color:#a6e22e">bak</span>

<span style="color:#75715e">//和命令
</span><span style="color:#75715e"></span>
cp mailbox mailbox<span style="color:#f92672">.</span><span style="color:#a6e22e">bak</span>
</code></pre></div><p>具有相同的含义。相对路径通常情况下更加方便和简洁。而它实现的功能和绝对路径安全相同。</p>
<p>一些程序需要访问某个特定的文件而不必关心当前的工作目录是什么。在这种情况下，应该使用绝对路径名。</p>
<p>支持层次目录结构的大多数操作系统在每个目录中有两个特殊的目录项<code>. </code>和<code> ..</code>，长读作 <code>dot</code> 和 <code>dotdot</code>。dot 指的是<code>当前目录</code>，dotdot 指的是<code>其父目录</code>（在根目录中例外，在根目录中指向自己）。可以参考下面的进程树来查看如何使用。
<img src="/img/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/648.jpeg" alt="">
一个进程的工作目录是 /usr/ast，它可采用 <code>..</code> 沿树向上，例如，可用命令</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">cp <span style="color:#f92672">../</span>lib<span style="color:#f92672">/</span>dictionary <span style="color:#f92672">.</span>
</code></pre></div><p>把文件<code> usr/lib/dictionary</code> 复制到自己的目录下，第一个路径告诉系统向上找（到 usr 目录），然后向下到 lib 目录，找到 dictionary 文件</p>
<p>第二个参数 <code>.</code> 指定当前的工作目录，当 cp 命令用目录名作为最后一个参数时，则把全部的文件复制到该目录中。当然，对于上述复制，键入</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">cp <span style="color:#f92672">/</span>usr<span style="color:#f92672">/</span>lib<span style="color:#f92672">/</span>dictionary <span style="color:#f92672">.</span>
</code></pre></div><p>是更常用的方法。用户这里采用 <code>. </code>可以避免键入两次 dictionary 。无论如何，键入</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">cp <span style="color:#f92672">/</span>usr<span style="color:#f92672">/</span>lib<span style="color:#f92672">/</span>dictionary dictionary
</code></pre></div><p>也可正常工作，就像键入</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">cp <span style="color:#f92672">/</span>usr<span style="color:#f92672">/</span>lib<span style="color:#f92672">/</span>dictionary <span style="color:#f92672">/</span>usr<span style="color:#f92672">/</span>lib<span style="color:#f92672">/</span>dictionary
</code></pre></div><p>一样。所有这些命令都能够完成同样的工作。</p>
<hr>
<h4 id="目录操作">目录操作</h4>
<p>不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</p>
<ul>
<li>
<p><code>Create</code>，创建目录，除了目录项 . 和 .. 外，目录内容为空。</p>
</li>
<li>
<p><code>Delete</code>，删除目录，只有空目录可以删除。只包含 . 和 .. 的目录被认为是空目录，这两个目录项通常不能删除</p>
</li>
<li>
<p><code>opendir</code>，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</p>
</li>
<li>
<p><code>closedir</code>，读目录结束后，应该关闭目录用于释放内部表空间。</p>
</li>
<li>
<p><code>readdir</code>，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</p>
</li>
<li>
<p><code>rename</code>，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</p>
</li>
<li>
<p><code>link</code>，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为硬链接(hard link)。</p>
</li>
<li>
<p><code>unlink</code>，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</p>
</li>
</ul>
<hr>
<h4 id="参考">参考</h4>
<p>《现代操作系统 第四版》</p>
<p><a href="https://mp.weixin.qq.com/s/ZLntjTf1jEwqdpln0hGq0w">又来搞事情了，这次女友让我研究如何实现一个文件系统</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;mid=2247485733&amp;idx=1&amp;sn=d6d3e55c442d64da14ab596a07422251&amp;chksm=fc45f4d6cb327dc0948b1fb3118e1118ac7b475d24df57a2e7484995884597e6a8c4c9536251&amp;scene=21#wechat_redirect">昨晚上女友问我，你知道啥是文件吗？于是就有了今天的文章</a></p>

                        </div>
                        
                        
                        
                        
                        <ul class="pager blog-pager">
                        
                        <li class="previous">
                        <a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-toggle="tooltip" data-placement="top" title="计算机之内存管理">&larr; 上一篇</a>
                        </li>
                         
                        <li class="next">
                        <a href="/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-string/" data-toggle="tooltip" data-placement="top" title="深入理解 String">下一篇 &rarr;</a>
                        </li>
                        
                        </ul>
                        
                        
                        


                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        <div class="panel panel-default sidebar-menu">
     
    <div class="panel-heading">
     <h3 class="panel-title">相关文章</h3>
    </div>
    <div class="panel-body">
     <ul class="nav nav-pills nav-stacked">
        
        <li><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><i class="fa fa-link"></i>计算机之内存管理</a></li>
         
        <li><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"><i class="fa fa-link"></i>计算机之进程与线程</a></li>
         
        <li><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8Bcpu/"><i class="fa fa-link"></i>计算机之CPU</a></li>
         
        <li><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%9F%BA%E7%A1%80/"><i class="fa fa-link"></i>计算机之基础</a></li>
         
        <li><a href="/blog/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%8C%87%E5%8D%97/"><i class="fa fa-link"></i>自学计算机科学指南</a></li>
         
     </ul>
    </div>
     
</div>





<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">分类</h3>
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            <li><a href="/categories/gateway"><i class="fa fa-navicon"></i>gateway (4)</a>
            </li>
            
            <li><a href="/categories/guava"><i class="fa fa-navicon"></i>guava (1)</a>
            </li>
            
            <li><a href="/categories/java"><i class="fa fa-navicon"></i>java (7)</a>
            </li>
            
            <li><a href="/categories/jvm"><i class="fa fa-navicon"></i>jvm (2)</a>
            </li>
            
            <li><a href="/categories/resilience4j"><i class="fa fa-navicon"></i>resilience4j (1)</a>
            </li>
            
            <li><a href="/categories/skywalking"><i class="fa fa-navicon"></i>skywalking (2)</a>
            </li>
            
            <li><a href="/categories/spring"><i class="fa fa-navicon"></i>spring (2)</a>
            </li>
            
            <li><a href="/categories/%e5%88%86%e5%b8%83%e5%bc%8f"><i class="fa fa-navicon"></i>分布式 (3)</a>
            </li>
            
            <li><a href="/categories/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b"><i class="fa fa-navicon"></i>并发编程 (17)</a>
            </li>
            
            <li><a href="/categories/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97"><i class="fa fa-navicon"></i>消息队列 (22)</a>
            </li>
            
            <li><a href="/categories/%e7%ae%97%e6%b3%95"><i class="fa fa-navicon"></i>算法 (3)</a>
            </li>
            
            <li><a href="/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba"><i class="fa fa-navicon"></i>计算机 (8)</a>
            </li>
            
        </ul>
    </div>
</div>







                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4>关于我</h4>

            <p>想当程序员的程序员</p>

            <hr class="hidden-md hidden-lg hidden-sm">

            <h4>友情连接</h4>

            <p>&nbsp;<a href="https://www.theyann.xyz:8123/home.html"> theyann</a></p>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/kafka-controller-%E6%A8%A1%E5%9D%97%E4%B8%80%E6%A6%82%E8%BF%B0/">
                            
                            <img src="/img/blog/kafka/kafkaLogo.jpg" class="img-responsive" alt="Kafka Controller 模块（一）概述">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/kafka-controller-%E6%A8%A1%E5%9D%97%E4%B8%80%E6%A6%82%E8%BF%B0/">Kafka Controller 模块（一）概述</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/kafka-%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%9D%97-replicamanager/">
                            
                            <img src="/img/blog/kafka/kafkaLogo.jpg" class="img-responsive" alt="Kafka 副本模块 ReplicaManager">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/kafka-%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%9D%97-replicamanager/">Kafka 副本模块 ReplicaManager</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/kafka-%E6%97%B6%E9%97%B4%E8%BD%AE-java-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0/">
                            
                            <img src="/img/blog/banners/0069RVTdgy1fu1i0mvc5yj31ji15ob2b.jpg" class="img-responsive" alt="Kafka 时间轮 Java 版本实现">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/kafka-%E6%97%B6%E9%97%B4%E8%BD%AE-java-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0/">Kafka 时间轮 Java 版本实现</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6 ">

            <h4>联系</h4>

            <p>个人微信</br>请备注姓名-公司信息</p><p><img src="/img/1.png"></p>
      

            <a href="/contact" class="btn btn-small btn-template-main">跳到联系页面</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020, siran all rights reserved.</p>
            
            
            <p class="pull-left">&nbsp;<a href="http://www.beian.miit.gov.cn/"> 苏ICP备20005919号</a></p>
            
            <p class="pull-right">
                模板来自 <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
                

                移植到 Hugo 来自 <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    <script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>
<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>

<script src="/js/prism.js"></script>


<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>


  </body>
</html>
