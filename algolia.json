[{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-06-06T07:37:42+08:00","fuzzywordcount":5400,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-06-06T07:37:42+08:00","objectID":"3271b9ab2747bfce7304642c22f43127","permalink":"/blog/kafka-controller-%E6%A8%A1%E5%9D%97%E4%B8%80%E6%A6%82%E8%BF%B0/","publishdate":"2020-06-06T07:37:42+08:00","readingtime":11,"relpermalink":"/blog/kafka-controller-%E6%A8%A1%E5%9D%97%E4%B8%80%E6%A6%82%E8%BF%B0/","summary":"","tags":["kafka"],"title":"Kafka Controller 模块（一）概述","translator":null,"url":"/blog/kafka-controller-%E6%A8%A1%E5%9D%97%E4%B8%80%E6%A6%82%E8%BF%B0/","weight":0,"wordcount":5372},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-06-01T10:37:42+08:00","fuzzywordcount":6700,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-06-01T10:37:42+08:00","objectID":"54d42885fb0a9b3d691220549cb3e9ca","permalink":"/blog/kafka-%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%9D%97-replicamanager/","publishdate":"2020-06-01T10:37:42+08:00","readingtime":14,"relpermalink":"/blog/kafka-%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%9D%97-replicamanager/","summary":"Kafka 的 Replication Mechanism 是为了保证 Kafka 的高可用性，也就是说一个每个分区可以有多个副本，并且会其副本集合中(AR) 选出一个副本作为 Leader 副本，所有的读写请求都由选举出来的 Leader 副本处理","tags":["kafka"],"title":"Kafka 副本模块 ReplicaManager","translator":null,"url":"/blog/kafka-%E5%89%AF%E6%9C%AC%E6%A8%A1%E5%9D%97-replicamanager/","weight":0,"wordcount":6653},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/0069RVTdgy1fu1i0mvc5yj31ji15ob2b.jpg","categories":["消息队列"],"date":"2020-05-14T20:37:42+08:00","fuzzywordcount":1300,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-05-14T20:37:42+08:00","objectID":"ebe9c6acdbab95a9d5cf854ababc6bb1","permalink":"/blog/kafka-%E6%97%B6%E9%97%B4%E8%BD%AE-java-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0/","publishdate":"2020-05-14T20:37:42+08:00","readingtime":3,"relpermalink":"/blog/kafka-%E6%97%B6%E9%97%B4%E8%BD%AE-java-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0/","summary":"","tags":["kafka"],"title":"Kafka 时间轮 Java 版本实现","translator":null,"url":"/blog/kafka-%E6%97%B6%E9%97%B4%E8%BD%AE-java-%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0/","weight":0,"wordcount":1200},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-05-07T18:37:42+08:00","fuzzywordcount":2100,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-05-07T18:37:42+08:00","objectID":"5e750bd293638e12df79fa414b9d2f0a","permalink":"/blog/kafka-%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9C%E4%BA%8Cdelayedproduce/","publishdate":"2020-05-07T18:37:42+08:00","readingtime":5,"relpermalink":"/blog/kafka-%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9C%E4%BA%8Cdelayedproduce/","summary":"Kafka Producer ack 设置为 all，需要所有的ISR 都接收到这条消息后才会返回。这里就用到了延迟操作。","tags":["kafka"],"title":"Kafka 延迟操作（二）DelayedProduce","translator":null,"url":"/blog/kafka-%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9C%E4%BA%8Cdelayedproduce/","weight":0,"wordcount":2050},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-05-07T08:37:42+08:00","fuzzywordcount":3800,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-05-07T08:37:42+08:00","objectID":"a62f5f8470b125ecfed0b5788a5afef6","permalink":"/blog/kafka-%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9C%E4%B8%80delayedoperationpurgatory/","publishdate":"2020-05-07T08:37:42+08:00","readingtime":8,"relpermalink":"/blog/kafka-%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9C%E4%B8%80delayedoperationpurgatory/","summary":"","tags":["kafka"],"title":"Kafka 延迟操作（一）DelayedOperationPurgatory","translator":null,"url":"/blog/kafka-%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9C%E4%B8%80delayedoperationpurgatory/","weight":0,"wordcount":3770},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-05-05T08:37:42+08:00","fuzzywordcount":9900,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-05-05T08:37:42+08:00","objectID":"33db2d5d30524882b149ac02245f4004","permalink":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E5%9B%9Blogmanager/","publishdate":"2020-05-05T08:37:42+08:00","readingtime":20,"relpermalink":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E5%9B%9Blogmanager/","summary":"Kafka 的所有的消息都是通过日志来存储的，它是通过 LogManager 来进行初始化的，Log 类是真正操作日志的，LogManager 是用来管理 Log 的。","tags":["kafka"],"title":"Kafka 日志模块（四）LogManager","translator":null,"url":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E5%9B%9Blogmanager/","weight":0,"wordcount":9849},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-05-03T16:37:42+08:00","fuzzywordcount":4600,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-05-03T16:37:42+08:00","objectID":"99ad7664ea85132f412e356af683a924","permalink":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%B8%89%E7%B4%A2%E5%BC%95/","publishdate":"2020-05-03T16:37:42+08:00","readingtime":10,"relpermalink":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%B8%89%E7%B4%A2%E5%BC%95/","summary":"","tags":["kafka"],"title":"Kafka 日志模块（三）索引","translator":null,"url":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%B8%89%E7%B4%A2%E5%BC%95/","weight":0,"wordcount":4511},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-05-03T15:37:42+08:00","fuzzywordcount":2400,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-05-03T15:37:42+08:00","objectID":"a4c0165b0c7d8c9d782bcff9648b68f6","permalink":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BA%8Clogsegment/","publishdate":"2020-05-03T15:37:42+08:00","readingtime":5,"relpermalink":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BA%8Clogsegment/","summary":"","tags":["kafka"],"title":"Kafka 日志模块（二）LogSegment","translator":null,"url":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BA%8Clogsegment/","weight":0,"wordcount":2316},{"author":"Siran","authorlink":null,"banner":"/img/blog/skywalking/logo.svg","categories":["Skywalking"],"date":"2020-05-02T23:37:42+08:00","fuzzywordcount":1400,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-05-02T23:37:42+08:00","objectID":"62891d728ef1675970ccc698ba41a4ab","permalink":"/blog/skywalking%E4%BA%8Cskywalkingagent-%E5%88%9D%E5%A7%8B%E5%8C%96/","publishdate":"2020-05-02T23:37:42+08:00","readingtime":3,"relpermalink":"/blog/skywalking%E4%BA%8Cskywalkingagent-%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"","tags":["Skywalking"],"title":"SkyWalking（二）SkyWalkingAgent 初始化","translator":null,"url":"/blog/skywalking%E4%BA%8Cskywalkingagent-%E5%88%9D%E5%A7%8B%E5%8C%96/","weight":0,"wordcount":1392},{"author":"Siran","authorlink":null,"banner":"/img/blog/skywalking/logo.svg","categories":["Skywalking"],"date":"2020-05-02T22:37:42+08:00","fuzzywordcount":2300,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-05-02T22:37:42+08:00","objectID":"d4d885e93675f0930fd6f34231afad1f","permalink":"/blog/skywalking%E4%B8%80opentracing/","publishdate":"2020-05-02T22:37:42+08:00","readingtime":5,"relpermalink":"/blog/skywalking%E4%B8%80opentracing/","summary":"SkyWalking 是 google 发表的 OpenTracing 标准的实现之一。","tags":["Skywalking"],"title":"Skywalking（一）OpenTracing","translator":null,"url":"/blog/skywalking%E4%B8%80opentracing/","weight":0,"wordcount":2238},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-05-01T15:37:42+08:00","fuzzywordcount":15200,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-05-01T15:37:42+08:00","objectID":"d66d7d0c0668fecb7dddc8918b23cc1d","permalink":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%B8%80log/","publishdate":"2020-05-01T15:37:42+08:00","readingtime":31,"relpermalink":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%B8%80log/","summary":"Kafka 使用`日志文件`的方式保存生产者发送的消息。每条消息都有一个 `offset` 值来标识它在分区中的偏移量，这个offset 是`逻辑值`，并不是消息实际存放的物理地址。","tags":["kafka"],"title":"Kafka 日志模块（一）Log","translator":null,"url":"/blog/kafka-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%B8%80log/","weight":0,"wordcount":15187},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fsxqadfbiwj31ji15o4qr.jpg","categories":["消息队列"],"date":"2020-04-27T10:37:42+08:00","fuzzywordcount":100,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-27T10:37:42+08:00","objectID":"6e70f1f2a3739fd3da400f5044f16a74","permalink":"/blog/kafka-%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83-log-%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98/","publishdate":"2020-04-27T10:37:42+08:00","readingtime":1,"relpermalink":"/blog/kafka-%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83-log-%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98/","summary":"","tags":["kafka"],"title":"Kafka 源码环境 Log 输出问题","translator":null,"url":"/blog/kafka-%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83-log-%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98/","weight":0,"wordcount":19},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-04-26T09:37:42+08:00","fuzzywordcount":1300,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-26T09:37:42+08:00","objectID":"6e37ac6fce5119e198670bdf1234c59e","permalink":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%89kafka-server-start.sh/","publishdate":"2020-04-26T09:37:42+08:00","readingtime":3,"relpermalink":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%89kafka-server-start.sh/","summary":"","tags":["kafka"],"title":"Kafka 服务端（三）kafka-server-start.sh","translator":null,"url":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%89kafka-server-start.sh/","weight":0,"wordcount":1294},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0zujg3g38j31400u0u10.jpg","categories":["分布式"],"date":"2020-04-24T19:12:42+08:00","fuzzywordcount":1100,"keywords":["分布式"],"lang":"zh","lastmod":"2020-04-24T19:12:42+08:00","objectID":"a1ed1de4a5bbe1bfb6e23db00d12649e","permalink":"/blog/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-bully/","publishdate":"2020-04-24T19:12:42+08:00","readingtime":3,"relpermalink":"/blog/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-bully/","summary":"","tags":["分布式"],"title":"分布式一致性算法 — Bully","translator":null,"url":"/blog/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-bully/","weight":0,"wordcount":1088},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-04-23T15:37:42+08:00","fuzzywordcount":1300,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-23T15:37:42+08:00","objectID":"f0af5dad67ec5cad63d6960b91f5cbcf","permalink":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%8Ckafkaapis/","publishdate":"2020-04-23T15:37:42+08:00","readingtime":3,"relpermalink":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%8Ckafkaapis/","summary":"","tags":["kafka"],"title":"Kafka 服务端（二）KafkaApis","translator":null,"url":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%8Ckafkaapis/","weight":0,"wordcount":1281},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-04-22T15:37:42+08:00","fuzzywordcount":14000,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-22T15:37:42+08:00","objectID":"60404f523e872f2547be19eecb73fe25","permalink":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E7%BD%91%E7%BB%9C%E5%B1%82/","publishdate":"2020-04-22T15:37:42+08:00","readingtime":28,"relpermalink":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E7%BD%91%E7%BB%9C%E5%B1%82/","summary":"","tags":["kafka"],"title":"Kafka 服务端（一）网络层","translator":null,"url":"/blog/kafka-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E7%BD%91%E7%BB%9C%E5%B1%82/","weight":0,"wordcount":13901},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-04-22T15:37:42+08:00","fuzzywordcount":4200,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-22T15:37:42+08:00","objectID":"b556914dbed6e9e6b694357ba7d1a4a8","permalink":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%89sender-%E7%BA%BF%E7%A8%8B/","publishdate":"2020-04-22T15:37:42+08:00","readingtime":9,"relpermalink":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%89sender-%E7%BA%BF%E7%A8%8B/","summary":"","tags":["kafka"],"title":"Kafka 生产者（三）Sender 线程","translator":null,"url":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%89sender-%E7%BA%BF%E7%A8%8B/","weight":0,"wordcount":4119},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-04-22T15:37:42+08:00","fuzzywordcount":800,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-22T15:37:42+08:00","objectID":"cdab6cd5430a7fa2a876120d1288ce1b","permalink":"/blog/kafkatools/","publishdate":"2020-04-22T15:37:42+08:00","readingtime":2,"relpermalink":"/blog/kafkatools/","summary":"","tags":["kafka"],"title":"KafkaTools","translator":null,"url":"/blog/kafkatools/","weight":0,"wordcount":776},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-04-21T10:37:42+08:00","fuzzywordcount":9300,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-21T10:37:42+08:00","objectID":"2bedb5d92d45927d69ad1eb54a29fc35","permalink":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%BA%8Crecordaccumulate/","publishdate":"2020-04-21T10:37:42+08:00","readingtime":19,"relpermalink":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%BA%8Crecordaccumulate/","summary":"","tags":["kafka"],"title":"Kafka 生产者（二）RecordAccumulate","translator":null,"url":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%BA%8Crecordaccumulate/","weight":0,"wordcount":9257},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-04-20T15:37:42+08:00","fuzzywordcount":5800,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-20T15:37:42+08:00","objectID":"82eb9fe32b5d94b3e4335b4e1820bf4c","permalink":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%80kafkaproducer/","publishdate":"2020-04-20T15:37:42+08:00","readingtime":12,"relpermalink":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%80kafkaproducer/","summary":"","tags":["kafka"],"title":"Kafka 生产者（一）KafkaProducer","translator":null,"url":"/blog/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%80kafkaproducer/","weight":0,"wordcount":5714},{"author":"Siran","authorlink":null,"banner":"/img/blog/kafka/kafkaLogo.jpg","categories":["消息队列"],"date":"2020-04-19T15:37:42+08:00","fuzzywordcount":1200,"keywords":["Kafka"],"lang":"zh","lastmod":"2020-04-19T15:37:42+08:00","objectID":"374cdb7ed8bba26de8418c8a2e19c727","permalink":"/blog/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","publishdate":"2020-04-19T15:37:42+08:00","readingtime":3,"relpermalink":"/blog/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","summary":"","tags":["kafka"],"title":"Kafka 基础概念","translator":null,"url":"/blog/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","weight":0,"wordcount":1108},{"author":"Siran","authorlink":null,"banner":"/img/blog/spring/spring.svg","categories":["gateway"],"date":"2020-04-18T18:37:42+08:00","fuzzywordcount":800,"keywords":["spring","Jdk源码","基础"],"lang":"zh","lastmod":"2020-04-18T18:37:42+08:00","objectID":"c5f36249150dc894aee3feb5b1cbdc5c","permalink":"/blog/gateway%E5%9B%9Bfilter/","publishdate":"2020-04-18T18:37:42+08:00","readingtime":2,"relpermalink":"/blog/gateway%E5%9B%9Bfilter/","summary":"","tags":["gateway"],"title":"Gateway（四）Filter","translator":null,"url":"/blog/gateway%E5%9B%9Bfilter/","weight":0,"wordcount":782},{"author":"Siran","authorlink":null,"banner":"/img/blog/spring/spring.svg","categories":["gateway"],"date":"2020-04-18T17:37:42+08:00","fuzzywordcount":2400,"keywords":["spring","Jdk源码","基础"],"lang":"zh","lastmod":"2020-04-18T17:37:42+08:00","objectID":"0650379365b8d13671a67922bca0d1c4","permalink":"/blog/gateway%E4%B8%89predicate/","publishdate":"2020-04-18T17:37:42+08:00","readingtime":5,"relpermalink":"/blog/gateway%E4%B8%89predicate/","summary":"","tags":["gateway"],"title":"Gateway（三）Predicate","translator":null,"url":"/blog/gateway%E4%B8%89predicate/","weight":0,"wordcount":2383},{"author":"Siran","authorlink":null,"banner":"/img/blog/spring/spring.svg","categories":["gateway"],"date":"2020-04-18T16:37:42+08:00","fuzzywordcount":4600,"keywords":["spring","Jdk源码","基础"],"lang":"zh","lastmod":"2020-04-18T16:37:42+08:00","objectID":"26d1b6339711ac019d4c32a487c81986","permalink":"/blog/gateway%E4%BA%8Croute/","publishdate":"2020-04-18T16:37:42+08:00","readingtime":10,"relpermalink":"/blog/gateway%E4%BA%8Croute/","summary":"","tags":["gateway"],"title":"Gateway（二）Route","translator":null,"url":"/blog/gateway%E4%BA%8Croute/","weight":0,"wordcount":4542},{"author":"Siran","authorlink":null,"banner":"/img/blog/spring/spring.svg","categories":["gateway"],"date":"2020-04-18T15:37:42+08:00","fuzzywordcount":3300,"keywords":["spring","Jdk源码","基础"],"lang":"zh","lastmod":"2020-04-18T15:37:42+08:00","objectID":"93b927052814ac0804a05daa7497922d","permalink":"/blog/gateway%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96/","publishdate":"2020-04-18T15:37:42+08:00","readingtime":7,"relpermalink":"/blog/gateway%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"","tags":["gateway"],"title":"Gateway（一）初始化","translator":null,"url":"/blog/gateway%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96/","weight":0,"wordcount":3215},{"author":"Siran","authorlink":null,"banner":"/img/blog/spring/spring.svg","categories":["spring"],"date":"2020-04-17T15:37:42+08:00","fuzzywordcount":3100,"keywords":["spring","Jdk源码","基础"],"lang":"zh","lastmod":"2020-04-17T15:37:42+08:00","objectID":"29ff718d98b8536cad3eac208c527a08","permalink":"/blog/spring-boot-%E6%B3%A8%E8%A7%A3-configurationproperties/","publishdate":"2020-04-17T15:37:42+08:00","readingtime":7,"relpermalink":"/blog/spring-boot-%E6%B3%A8%E8%A7%A3-configurationproperties/","summary":"","tags":["spring boot"],"title":"Spring Boot 注解 @ConfigurationProperties","translator":null,"url":"/blog/spring-boot-%E6%B3%A8%E8%A7%A3-configurationproperties/","weight":0,"wordcount":3010},{"author":"Siran","authorlink":null,"banner":"/img/blog/resilience4j/1587010943655.png","categories":["Resilience4j"],"date":"2020-04-15T16:37:42+08:00","fuzzywordcount":4300,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-04-15T16:37:42+08:00","objectID":"812c2a51fc8287fbb8b7f24c1ce2d1c9","permalink":"/blog/resilience4j-circuitbreaker-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-04-15T16:37:42+08:00","readingtime":9,"relpermalink":"/blog/resilience4j-circuitbreaker-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"","tags":["Resilience4j"],"title":"Resilience4j CircuitBreaker 源码分析","translator":null,"url":"/blog/resilience4j-circuitbreaker-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":4212},{"author":"Siran","authorlink":null,"banner":"/img/blog/spring/spring.svg","categories":["spring"],"date":"2020-04-14T15:37:42+08:00","fuzzywordcount":3700,"keywords":["spring","Jdk源码","基础"],"lang":"zh","lastmod":"2020-04-14T15:37:42+08:00","objectID":"0d878890828a5c4d9fdf7cb60e43393b","permalink":"/blog/spring-boot-additionallocation%E5%8F%82%E6%95%B0/","publishdate":"2020-04-14T15:37:42+08:00","readingtime":8,"relpermalink":"/blog/spring-boot-additionallocation%E5%8F%82%E6%95%B0/","summary":"","tags":["spring boot"],"title":"Spring Boot additional—location 参数","translator":null,"url":"/blog/spring-boot-additionallocation%E5%8F%82%E6%95%B0/","weight":0,"wordcount":3604},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fyd9djbbf5j313z0u0u0z.jpg","categories":["Java"],"date":"2020-04-09T16:37:42+08:00","fuzzywordcount":4900,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-04-09T16:37:42+08:00","objectID":"a3c051f9e054b79fa417c3f6b6ff95de","permalink":"/blog/java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/","publishdate":"2020-04-09T16:37:42+08:00","readingtime":10,"relpermalink":"/blog/java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/","summary":"书籍《Java实战》一些操作的汇总","tags":["Java"],"title":"Java8—新特性汇总.md","translator":null,"url":"/blog/java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/","weight":0,"wordcount":4872},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g16sdv0suej31400u04qs.jpg","categories":["Java"],"date":"2020-04-09T16:37:42+08:00","fuzzywordcount":1500,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-04-09T16:37:42+08:00","objectID":"66fcdbbc9410521cf9a112bbbd1e56d5","permalink":"/blog/java8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api/","publishdate":"2020-04-09T16:37:42+08:00","readingtime":3,"relpermalink":"/blog/java8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api/","summary":"书籍《Java实战》一些操作的汇总","tags":["Java"],"title":"Java8—日期时间API","translator":null,"url":"/blog/java8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api/","weight":0,"wordcount":1477},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g1evbtk455j30rs0kuwxe.jpg","categories":["JVM"],"date":"2020-03-31T11:37:42+08:00","fuzzywordcount":9600,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-31T11:37:42+08:00","objectID":"00fcebe82a63ad056373e6027fbb85d6","permalink":"/blog/%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8Areference%E7%B1%BB/","publishdate":"2020-03-31T11:37:42+08:00","readingtime":19,"relpermalink":"/blog/%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8Areference%E7%B1%BB/","summary":"Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。","tags":["JVM"],"title":"引用以及Reference类","translator":null,"url":"/blog/%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8Areference%E7%B1%BB/","weight":0,"wordcount":9515},{"author":"Siran","authorlink":null,"banner":"/img/blog/Java基础/WechatIMG5.jpeg","categories":["并发编程"],"date":"2020-03-23T11:37:42+08:00","fuzzywordcount":3000,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-23T11:37:42+08:00","objectID":"87ba89ae21fdf124b7068bf798a28b03","permalink":"/blog/printlnsleepinteger%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%85%E4%BA%8B/","publishdate":"2020-03-23T11:37:42+08:00","readingtime":6,"relpermalink":"/blog/printlnsleepinteger%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%85%E4%BA%8B/","summary":"","tags":["并发理论"],"title":"println、sleep、Integer与线程安全的一些故事","translator":null,"url":"/blog/printlnsleepinteger%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%85%E4%BA%8B/","weight":0,"wordcount":2986},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0ku5ojo3gj31400u07wk.jpg","categories":["JVM"],"date":"2020-03-22T16:37:42+08:00","fuzzywordcount":9000,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-22T16:37:42+08:00","objectID":"45ebef41c5b4fd6933cd73989e666992","permalink":"/blog/jvm-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","publishdate":"2020-03-22T16:37:42+08:00","readingtime":18,"relpermalink":"/blog/jvm-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","summary":"Java 虚拟机在执行Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间","tags":["JVM"],"title":"JVM 内存区域与内存溢出异常","translator":null,"url":"/blog/jvm-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","weight":0,"wordcount":8994},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g16sdv0suej31400u04qs.jpg","categories":["Guava"],"date":"2020-03-21T22:12:42+08:00","fuzzywordcount":5600,"keywords":["Guava"],"lang":"zh","lastmod":"2020-03-21T22:12:42+08:00","objectID":"046873a2585304f333fc67394cb94b7c","permalink":"/blog/guava-%E4%B8%80-ratelimiter/","publishdate":"2020-03-21T22:12:42+08:00","readingtime":12,"relpermalink":"/blog/guava-%E4%B8%80-ratelimiter/","summary":"每个API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时候,我们就必须考虑限流来保证接口的可用性或者降级可用性。以防止非预期的请求对系统压力过大而引起的系统瘫痪。","tags":["Guava"],"title":"Guava (一) ：RateLimiter","translator":null,"url":"/blog/guava-%E4%B8%80-ratelimiter/","weight":0,"wordcount":5540},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0syv8mc7jj31400u0qv5.jpg","categories":["计算机"],"date":"2020-03-21T15:12:42+08:00","fuzzywordcount":2300,"keywords":["计算机","HTTP"],"lang":"zh","lastmod":"2020-03-21T15:12:42+08:00","objectID":"84ae84133cf4e9fd1f4a0ec47fb2216b","permalink":"/blog/http-%E6%8B%BE%E9%81%97tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","publishdate":"2020-03-21T15:12:42+08:00","readingtime":5,"relpermalink":"/blog/http-%E6%8B%BE%E9%81%97tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","summary":"","tags":["协议"],"title":"HTTP 拾遗——TCP建立连接为什么需要三次握手","translator":null,"url":"/blog/http-%E6%8B%BE%E9%81%97tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","weight":0,"wordcount":2228},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcgy1ft5wypaul5j31ji15ob2b.jpg","categories":["并发编程"],"date":"2020-03-20T16:37:42+08:00","fuzzywordcount":7400,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-20T16:37:42+08:00","objectID":"8dbbb7e3c22c60d13754a594df37febc","permalink":"/blog/synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","publishdate":"2020-03-20T16:37:42+08:00","readingtime":15,"relpermalink":"/blog/synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","summary":"synchronized 关键字是 Java里面用来进行同步的。它编译后，会在同步块的前后分别生成 mointorenter 和 mointerexit 字节码指令，这两个字节码指令都需要一个引用类型的参数来指定要锁定和解锁的对象。","tags":["并发关键字"],"title":"synchronized 的实现原理","translator":null,"url":"/blog/synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","weight":0,"wordcount":7391},{"author":"Siran","authorlink":null,"banner":"/img/blog/Java基础/1.jpg","categories":["并发编程"],"date":"2020-03-20T16:37:42+08:00","fuzzywordcount":2900,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-20T16:37:42+08:00","objectID":"8d87c837ebb85ec8ef488428d5619cb9","permalink":"/blog/volatile-%E8%A7%A3%E6%9E%90/","publishdate":"2020-03-20T16:37:42+08:00","readingtime":6,"relpermalink":"/blog/volatile-%E8%A7%A3%E6%9E%90/","summary":"在多线程并发编程中synchronized 和 volatile 扮演着很重要的角色，volatile是轻量级的 synchronized,它能保证共享变量在多处理器下的可见性","tags":["并发关键字"],"title":"volatile 解析","translator":null,"url":"/blog/volatile-%E8%A7%A3%E6%9E%90/","weight":0,"wordcount":2825},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fyc9vljbxej31400u0u0z.jpg","categories":["计算机"],"date":"2020-03-19T19:12:42+08:00","fuzzywordcount":14900,"keywords":["计算机","HTTP"],"lang":"zh","lastmod":"2020-03-19T19:12:42+08:00","objectID":"ddcad0e80324e4879333b675d959e2d2","permalink":"/blog/http-%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/","publishdate":"2020-03-19T19:12:42+08:00","readingtime":30,"relpermalink":"/blog/http-%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/","summary":"HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范","tags":["协议"],"title":"HTTP 协议总结.md","translator":null,"url":"/blog/http-%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/","weight":0,"wordcount":14863},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fyl57bnk4uj31400u0npf.jpg","categories":["并发编程"],"date":"2020-03-19T10:30:42+08:00","fuzzywordcount":8000,"keywords":["Java","并发编程"],"lang":"zh","lastmod":"2020-03-19T10:30:42+08:00","objectID":"d48aa0ec1163f7bafcfb23e860d1e972","permalink":"/blog/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88concurrenthashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-03-19T10:30:42+08:00","readingtime":16,"relpermalink":"/blog/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88concurrenthashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ConcurrentHashMap是HashMap的线程安全版本，内部也是使用（数组 + 链表 + 红黑树）的结构来存储元素。","tags":["Map"],"title":"并发集合——ConcurrentHashMap 源码分析","translator":null,"url":"/blog/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88concurrenthashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":7943},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1frtdesg6toj30rs0kuwtz.jpg","categories":["并发编程"],"date":"2020-03-19T10:30:42+08:00","fuzzywordcount":9600,"keywords":["Java","并发编程"],"lang":"zh","lastmod":"2020-03-19T10:30:42+08:00","objectID":"c6a95eb8c30fd42cde6c07880ef4d854","permalink":"/blog/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88concurrentskiplistmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-03-19T10:30:42+08:00","readingtime":20,"relpermalink":"/blog/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88concurrentskiplistmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。","tags":["Map"],"title":"并发集合——ConcurrentSkipListMap 源码分析","translator":null,"url":"/blog/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88concurrentskiplistmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":9566},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g16sdv0suej31400u04qs.jpg","categories":["Java"],"date":"2020-03-19T10:20:42+08:00","fuzzywordcount":9000,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-19T10:20:42+08:00","objectID":"d593a8f9eb739674d541bc9ef58431cc","permalink":"/blog/hashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-03-19T10:20:42+08:00","readingtime":18,"relpermalink":"/blog/hashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"HashMap 采用key/value存储结构，每个key 对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序。","tags":["Map"],"title":"HashMap 源码分析","translator":null,"url":"/blog/hashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":8995},{"author":"Siran","authorlink":null,"banner":"/img/blog/Java基础/2.jpg","categories":["Java"],"date":"2020-03-19T09:37:42+08:00","fuzzywordcount":4700,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-19T09:37:42+08:00","objectID":"c4e9a04eee5b273989eee7b065f98ceb","permalink":"/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-string/","publishdate":"2020-03-19T09:37:42+08:00","readingtime":10,"relpermalink":"/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-string/","summary":"由于String 使用过于频繁，Java为了避免在一个系统中产生大量的String对象引入了字符串常量池","tags":["Java"],"title":"深入理解 String","translator":null,"url":"/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-string/","weight":0,"wordcount":4666},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g1euye93ccj30rs0kue81.jpg","categories":["计算机"],"date":"2020-03-17T15:12:42+08:00","fuzzywordcount":8900,"keywords":["计算机"],"lang":"zh","lastmod":"2020-03-17T15:12:42+08:00","objectID":"22f4895bc5f738f186f40bcb7db41208","permalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","publishdate":"2020-03-17T15:12:42+08:00","readingtime":18,"relpermalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","summary":"所有的应用程序都需要存储和检索信息。当进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受虚拟地址空间大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了","tags":["计算机"],"title":"计算机之文件系统","translator":null,"url":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","weight":0,"wordcount":8856},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcgy1ftpqcrh9xoj30rs0kuq8z.jpg","categories":["计算机"],"date":"2020-03-16T19:12:42+08:00","fuzzywordcount":14900,"keywords":["计算机"],"lang":"zh","lastmod":"2020-03-16T19:12:42+08:00","objectID":"6b652aabe367516636c8fb9826e45923","permalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","publishdate":"2020-03-16T19:12:42+08:00","readingtime":30,"relpermalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","summary":"内存(RAM) 是一件非常重要的资源，必须要认真对待内存。虽然目前大多数内存的增长速度要比 IBM 7094 要快的多，但是，程序大小的增长要比内存的增长还快很多。不管存储器有多大，程序大小的增长速度比内存容量的增长速度要快的多。","tags":["计算机"],"title":"计算机之内存管理","translator":null,"url":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","weight":0,"wordcount":14817},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fy5cgpcejxj30rs0ktawa.jpg","categories":["计算机"],"date":"2020-03-15T19:12:42+08:00","fuzzywordcount":28500,"keywords":["计算机"],"lang":"zh","lastmod":"2020-03-15T19:12:42+08:00","objectID":"49513985ca787192b77ff768e29889ab","permalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","publishdate":"2020-03-15T19:12:42+08:00","readingtime":57,"relpermalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","summary":"操作系统中最核心的概念是进程，这是对正在运行程序的一个抽象。即时可以使用的CPU只有一个，但是它们也具有支持(伪)并发操作的能力，它们将一个单独的CPU变换成多个 虚拟的CPU","tags":["计算机"],"title":"计算机之进程与线程","translator":null,"url":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","weight":0,"wordcount":28436},{"author":"Siran","authorlink":null,"banner":"/img/blog/计算机/CPU.jpeg","categories":["计算机"],"date":"2020-03-14T12:12:42+08:00","fuzzywordcount":5100,"keywords":["计算机"],"lang":"zh","lastmod":"2020-03-14T12:12:42+08:00","objectID":"80c544b7960fde628d2928dbff4afc90","permalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8Bcpu/","publishdate":"2020-03-14T12:12:42+08:00","readingtime":11,"relpermalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8Bcpu/","summary":"CPU 的全称是 Central Processing Unit ，它是你的电脑中最硬件的组件","tags":["计算机"],"title":"计算机之CPU","translator":null,"url":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8Bcpu/","weight":0,"wordcount":5075},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0crj27wpij31400u0hdu.jpg","categories":["计算机"],"date":"2020-03-13T19:12:42+08:00","fuzzywordcount":2000,"keywords":["计算机"],"lang":"zh","lastmod":"2020-03-13T19:12:42+08:00","objectID":"01fb3616f98ffc3ed95aa694f936bb5a","permalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%9F%BA%E7%A1%80/","publishdate":"2020-03-13T19:12:42+08:00","readingtime":4,"relpermalink":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%9F%BA%E7%A1%80/","summary":"","tags":["计算机"],"title":"计算机之基础","translator":null,"url":"/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%9F%BA%E7%A1%80/","weight":0,"wordcount":1976},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs2ua9kohvj30rs0kub29.jpg","categories":["计算机"],"date":"2020-03-12T19:12:42+08:00","fuzzywordcount":8300,"keywords":["计算机"],"lang":"zh","lastmod":"2020-03-12T19:12:42+08:00","objectID":"de41eb426fd360f0855cfad987f22364","permalink":"/blog/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%8C%87%E5%8D%97/","publishdate":"2020-03-12T19:12:42+08:00","readingtime":17,"relpermalink":"/blog/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%8C%87%E5%8D%97/","summary":"如果你是一个自学成才的工程师，或者从编程培训班毕业，那么你很有必要学习计算机科学。幸运的是，不必为此花上数年光阴和不菲费用去攻读一个学位：仅仅依靠自己，你就可以获得世界一流水平的教育","tags":["计算机"],"title":"自学计算机科学指南","translator":null,"url":"/blog/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%8C%87%E5%8D%97/","weight":0,"wordcount":8269},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNc79ly1g1wrwnznblj31400u0x6p.jpg","categories":["并发编程"],"date":"2020-03-08T16:37:42+08:00","fuzzywordcount":4300,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-08T16:37:42+08:00","objectID":"637bf86cd8182fc867b0299c7c7ed69e","permalink":"/blog/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/","publishdate":"2020-03-08T16:37:42+08:00","readingtime":9,"relpermalink":"/blog/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/","summary":"操作系统为了方便用户使用对硬件进行抽象，屏蔽各种细节的处理，而Java内存模型是在硬件内存模型上的更高层的抽象，它屏蔽了各种硬件和操作系统访问的差异性，保证了Java程序在各种平台下对内存的访问都能达到一致的效果。","tags":["并发理论"],"title":"Java内存模型详解","translator":null,"url":"/blog/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/","weight":0,"wordcount":4268},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0vesgata2j31420u01l1.jpg","categories":["Java"],"date":"2020-03-08T16:37:42+08:00","fuzzywordcount":2100,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-08T16:37:42+08:00","objectID":"a7f1686b99037a37f534514587d6a8ff","permalink":"/blog/linkedhashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-03-08T16:37:42+08:00","readingtime":5,"relpermalink":"/blog/linkedhashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"LinkedHashMap 继承HashMap，拥有HashMap的所有特性，并且添加了顺序访问的特点，HashMap是无序的内部维护一个双向链表， 能保证元素的插入是顺序访问的，也能以访问顺序访问，可以用来实现LRU缓存策略。","tags":["Map"],"title":"LinkedHashMap 源码分析","translator":null,"url":"/blog/linkedhashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2087},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fsiynxp5e2j30rs0ku7l4.jpg","categories":["Java"],"date":"2020-03-08T16:37:42+08:00","fuzzywordcount":3400,"keywords":["Java","基础"],"lang":"zh","lastmod":"2020-03-08T16:37:42+08:00","objectID":"beb1b1a3f59b5488dfd8e0ed6c4d1a77","permalink":"/blog/weakhashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-03-08T16:37:42+08:00","readingtime":7,"relpermalink":"/blog/weakhashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"WeakHashMap是一种弱引用map，内部的key会存储为弱引用，当jvm gc的时候，如果这些key没有强引用存在的话，会被gc回收掉，下一次当我们操作map的时候会把对应的Entry整个删除掉，基于这种特性，WeakHashMap特别适用于缓存处理。","tags":["Map"],"title":"WeakHashMap 源码分析","translator":null,"url":"/blog/weakhashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":3332},{"author":"Siran","authorlink":null,"banner":"/img/blog/算法/企业微信截图_f7d2e2c8-b8d6-4ee5-8179-857f553e3a88.png","categories":["算法"],"date":"2020-03-08T16:37:42+08:00","fuzzywordcount":1100,"keywords":["算法","基础","动态规划"],"lang":"zh","lastmod":"2020-03-08T16:37:42+08:00","objectID":"0cb11557da8326d53b00f1ab817ec15d","permalink":"/blog/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/","publishdate":"2020-03-08T16:37:42+08:00","readingtime":3,"relpermalink":"/blog/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/","summary":"","tags":["算法"],"title":"动态规划经典问题- 股票买卖","translator":null,"url":"/blog/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/","weight":0,"wordcount":1097},{"author":"Siran","authorlink":null,"banner":"/img/blog/Java基础/WechatIMG3.jpeg","categories":["算法"],"date":"2020-03-08T16:37:42+08:00","fuzzywordcount":800,"keywords":["算法","基础"],"lang":"zh","lastmod":"2020-03-08T16:37:42+08:00","objectID":"bad932b7cf208ceb01c19fc0cb0e72a4","permalink":"/blog/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0lfu%E7%AE%97%E6%B3%95/","publishdate":"2020-03-08T16:37:42+08:00","readingtime":2,"relpermalink":"/blog/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0lfu%E7%AE%97%E6%B3%95/","summary":"","tags":["算法"],"title":"如何实现LFU算法","translator":null,"url":"/blog/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0lfu%E7%AE%97%E6%B3%95/","weight":0,"wordcount":732},{"author":"Siran","authorlink":null,"banner":"/img/blog/Java基础/WechatIMG4.jpeg","categories":["算法"],"date":"2020-03-08T15:37:42+08:00","fuzzywordcount":500,"keywords":["算法","基础"],"lang":"zh","lastmod":"2020-03-08T15:37:42+08:00","objectID":"ed48372a3f0df952c5b1b0824e092343","permalink":"/blog/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0lru%E7%AE%97%E6%B3%95/","publishdate":"2020-03-08T15:37:42+08:00","readingtime":1,"relpermalink":"/blog/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0lru%E7%AE%97%E6%B3%95/","summary":"","tags":["算法"],"title":"如何实现LRU算法","translator":null,"url":"/blog/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0lru%E7%AE%97%E6%B3%95/","weight":0,"wordcount":401},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0n3qqw0xqj31400u0hdt.jpg","categories":["并发编程"],"date":"2020-03-05T12:37:42+08:00","fuzzywordcount":1800,"keywords":["原子类","基础"],"lang":"zh","lastmod":"2020-03-05T12:37:42+08:00","objectID":"ccd59f591a5059c1bece2120387135b9","permalink":"/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/","publishdate":"2020-03-05T12:37:42+08:00","readingtime":4,"relpermalink":"/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/","summary":"AtomicStampedReference是jdk1.5出的一个类，用于解决其他原子类无法解决的ABA问题。","tags":["原子类"],"title":"AtomicStampedReference 详解","translator":null,"url":"/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/","weight":0,"wordcount":1746},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0d0qfcwpfj31400u0u11.jpg","categories":["并发编程"],"date":"2020-03-05T11:37:42+08:00","fuzzywordcount":3800,"keywords":["原子类","Jdk源码","基础"],"lang":"zh","lastmod":"2020-03-05T11:37:42+08:00","objectID":"5a0179470ff6d60f276df6cc543023e2","permalink":"/blog/longadder-%E8%AF%A6%E8%A7%A3/","publishdate":"2020-03-05T11:37:42+08:00","readingtime":8,"relpermalink":"/blog/longadder-%E8%AF%A6%E8%A7%A3/","summary":"LongAdder 类是jdk1.8新增的原子类，在多线程环境下，它的性能比普通的Atomic类性能高很多，继承 Striped64，通过Striped64的Cell来实现功能，并且在ConcurrentHashMap中也用了Striped64的Cell。","tags":["原子类"],"title":"LongAdder 详解","translator":null,"url":"/blog/longadder-%E8%AF%A6%E8%A7%A3/","weight":0,"wordcount":3752},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["消息队列"],"date":"2020-03-04T22:37:42+08:00","fuzzywordcount":1600,"keywords":["消息中间件","Pulsar"],"lang":"zh","lastmod":"2020-03-04T22:37:42+08:00","objectID":"39b54547ca327bc68e2d1fb83f1b61ec","permalink":"/blog/pulsar-topic-discovery/","publishdate":"2020-03-04T22:37:42+08:00","readingtime":4,"relpermalink":"/blog/pulsar-topic-discovery/","summary":"","tags":["Pulsar"],"title":"Pulsar - Topic Discovery","translator":null,"url":"/blog/pulsar-topic-discovery/","weight":0,"wordcount":1572},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["消息队列"],"date":"2020-03-04T13:38:42+08:00","fuzzywordcount":3200,"keywords":["消息中间件","Pulsar"],"lang":"zh","lastmod":"2020-03-04T13:38:42+08:00","objectID":"6bbed5ff8d026bf5f00c9ae46c8e321a","permalink":"/blog/pulsar-message-lifecycle/","publishdate":"2020-03-04T13:38:42+08:00","readingtime":7,"relpermalink":"/blog/pulsar-message-lifecycle/","summary":"","tags":["Pulsar"],"title":"Pulsar - Message Lifecycle","translator":null,"url":"/blog/pulsar-message-lifecycle/","weight":0,"wordcount":3101},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["消息队列"],"date":"2020-03-04T13:38:42+08:00","fuzzywordcount":3900,"keywords":["消息中间件","Pulsar"],"lang":"zh","lastmod":"2020-03-04T13:38:42+08:00","objectID":"070b26679f8de85ceb3ee0f1cd3b527b","permalink":"/blog/pulsar-vs.-kafka%E4%BA%8C-%E4%BB%A5segment%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9E%B6%E6%9E%84/","publishdate":"2020-03-04T13:38:42+08:00","readingtime":8,"relpermalink":"/blog/pulsar-vs.-kafka%E4%BA%8C-%E4%BB%A5segment%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9E%B6%E6%9E%84/","summary":"","tags":["Pulsar"],"title":"Pulsar VS. Kafka（二）: 以Segment为中心的架构","translator":null,"url":"/blog/pulsar-vs.-kafka%E4%BA%8C-%E4%BB%A5segment%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9E%B6%E6%9E%84/","weight":0,"wordcount":3853},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["消息队列"],"date":"2020-03-04T13:37:42+08:00","fuzzywordcount":5600,"keywords":["消息中间件","Pulsar"],"lang":"zh","lastmod":"2020-03-04T13:37:42+08:00","objectID":"dc72a7d00198d5e228d40f2e5bea2cdf","permalink":"/blog/pulsar-vs.-kafka-%E4%B8%80-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B/","publishdate":"2020-03-04T13:37:42+08:00","readingtime":12,"relpermalink":"/blog/pulsar-vs.-kafka-%E4%B8%80-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B/","summary":"Pulsar的特性包括消息的持久化存储，多租户，多机房互联互备，加密和安全性等。有比较强的健壮性，高可用性和可预测的延迟等。","tags":["Pulsar"],"title":"Pulsar VS. Kafka (一): 消息消费模型","translator":null,"url":"/blog/pulsar-vs.-kafka-%E4%B8%80-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B/","weight":0,"wordcount":5541},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/6ce41a46gy1g31wxsf5ibj20rs0ku10r.jpg","categories":["并发编程"],"date":"2020-03-01T19:12:42+08:00","fuzzywordcount":6000,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-03-01T19:12:42+08:00","objectID":"af77c01358398afcab4dd76772ae0039","permalink":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-03-01T19:12:42+08:00","readingtime":12,"relpermalink":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"Condition可以替代传统的Object中的wait()、notify()和notifyAll()方法来实现线程间的通信，使线程间协作更加安全和高效。","tags":["AQS"],"title":"Condition 源码分析","translator":null,"url":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":5924},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fug0hms6vej31jk15ou0x.jpg","categories":["并发编程"],"date":"2020-02-15T19:12:42+08:00","fuzzywordcount":3800,"keywords":["线程池","基础"],"lang":"zh","lastmod":"2020-02-15T19:12:42+08:00","objectID":"7e43ae6f733601bf6ca2ba5ed63a42ac","permalink":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-15T19:12:42+08:00","readingtime":8,"relpermalink":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"FutureTask 是一个可以取消的异步计算任务，实现Future，Runnable。提供超时控制、可以获取线程执行后的返回结果、可以取消。","tags":["线程池"],"title":"FutureTask 源码分析","translator":null,"url":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":3744},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs2ua9kohvj30rs0kub29.jpg","categories":["分布式"],"date":"2020-02-13T19:12:42+08:00","fuzzywordcount":8000,"keywords":["分布式"],"lang":"zh","lastmod":"2020-02-13T19:12:42+08:00","objectID":"1e30dd2cf39d7b81395d74cb244963fa","permalink":"/blog/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-raft/","publishdate":"2020-02-13T19:12:42+08:00","readingtime":16,"relpermalink":"/blog/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-raft/","summary":"Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是比 Paxos 更容易理解并且更容易实现。","tags":["分布式"],"title":"分布式一致性算法 — Raft","translator":null,"url":"/blog/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-raft/","weight":0,"wordcount":7982},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs3o6ljkknj30rs0ku4qp.jpg","categories":["Java"],"date":"2020-02-12T19:12:42+08:00","fuzzywordcount":2900,"keywords":["集合","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-12T19:12:42+08:00","objectID":"36e23969a903b47b59b720ce424589c8","permalink":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-12T19:12:42+08:00","readingtime":6,"relpermalink":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"PriorityQueue里的每个元素都会进行排序，每次弹出一个元素要么是最大的要么是最小的，取决于排序规则。","tags":["Queue"],"title":"PriorityQueue 源码分析","translator":null,"url":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2812},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcgy1ftdx65tgduj30rs0kugov.jpg","categories":["并发编程"],"date":"2020-02-05T19:12:42+08:00","fuzzywordcount":4600,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-05T19:12:42+08:00","objectID":"18d4d93336c5e2fc08c03cc3143dd3ed","permalink":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-05T19:12:42+08:00","readingtime":10,"relpermalink":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。","tags":["AQS"],"title":"CountDownLatch 源码分析","translator":null,"url":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":4569},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs0iwgalk7j30rs0kux38.jpg","categories":["分布式"],"date":"2020-02-05T12:12:42+08:00","fuzzywordcount":100,"keywords":["分布式"],"lang":"zh","lastmod":"2020-02-05T12:12:42+08:00","objectID":"bc0eb6cff4dff4eb0faad2d6bf8dfd26","permalink":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","publishdate":"2020-02-05T12:12:42+08:00","readingtime":1,"relpermalink":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","summary":"","tags":["分布式"],"title":"Raft 思维导图","translator":null,"url":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","weight":0,"wordcount":10},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs77zshhihj30rs0kunab.jpg","categories":["并发编程"],"date":"2020-02-05T11:12:42+08:00","fuzzywordcount":3100,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-05T11:12:42+08:00","objectID":"ee211a3ae46d588c78049cdda68d8654","permalink":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-05T11:12:42+08:00","readingtime":7,"relpermalink":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ReentrantReadWriteLock 是什么?","tags":["AQS"],"title":"ReentrantReadWriteLock 源码分析","translator":null,"url":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":3053},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcgy1ftd20xaj6jj31ji15oqv6.jpg","categories":["并发编程"],"date":"2020-02-04T19:12:42+08:00","fuzzywordcount":2500,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-04T19:12:42+08:00","objectID":"423a24bccdb26a0b9e62651f8dd08fd0","permalink":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-04T19:12:42+08:00","readingtime":5,"relpermalink":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"CyclicBarrier(回声栅栏)根据Javadoc描述，它会阻塞一组线程直到这些线程同时达到某个条件才继续执行。它就像一个栅栏一样，当一组线程都到达了栅栏处才继续往下走。","tags":["AQS"],"title":"CyclicBarrier 源码分析","translator":null,"url":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2448},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fyb51imvdpj31420u0hdt.jpg","categories":["并发编程"],"date":"2020-01-18T19:12:42+08:00","fuzzywordcount":10500,"keywords":["线程池","基础"],"lang":"zh","lastmod":"2020-01-18T19:12:42+08:00","objectID":"86d38dc1237f60422707b5dd45f6644e","permalink":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-18T19:12:42+08:00","readingtime":21,"relpermalink":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ThreadPoolExecutor中常用参数有哪些，作用是什么？任务提交后，ThreadPoolExecutor会按照什么策略去创建线程用于执行提交任务？","tags":["线程池"],"title":"ThreadPoolExecutor 源码分析","translator":null,"url":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":10404},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs1hvk6nt7j30rs0kunjm.jpg","categories":["并发编程"],"date":"2020-01-05T19:12:42+08:00","fuzzywordcount":6900,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-01-05T19:12:42+08:00","objectID":"ae62462bf92447a1fcedd559363e10b6","permalink":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-05T19:12:42+08:00","readingtime":14,"relpermalink":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"通常使用锁就是 synchronized，经过 jdk 的一系列优化引入偏向锁、轻量级锁、重量级锁等概念，性能也是有很大的提高。","tags":["AQS"],"title":"ReentrantLock 源码分析","translator":null,"url":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":6878},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNc79ly1g1wrp8d29yj31400u0kjm.jpg","categories":["并发编程"],"date":"2020-01-05T12:12:42+08:00","fuzzywordcount":5300,"keywords":["线程池","基础"],"lang":"zh","lastmod":"2020-01-05T12:12:42+08:00","objectID":"4ede7e693da99df08ae7ed398cab1cbd","permalink":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-05T12:12:42+08:00","readingtime":11,"relpermalink":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ScheduledThreadPoolExecutor 定义了一个延迟队列 DelayedWorkQueue，这个队列是基于二叉堆来实现的，每次都会把最快要执行的任务放入堆顶(最小堆)。","tags":["线程池"],"title":"ScheduledThreadPoolExecutor 源码分析","translator":null,"url":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":5244},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNc79ly1g2bd7nfv72j31400u0x6s.jpg","categories":["并发编程"],"date":"2018-06-05T19:12:42+08:00","fuzzywordcount":2400,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2018-06-05T19:12:42+08:00","objectID":"77d7e0cfee3c1e35259e4ac050677001","permalink":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2018-06-05T19:12:42+08:00","readingtime":5,"relpermalink":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"基于微服务的架构是未来的趋势，但是实现这种架构会面临许多困难。现代应用架构远比过去的架构复杂，因此实现微服务架构将会带来了一系列特殊的挑战，而服务网格可以帮我们解决很多问题。","tags":["AQS"],"title":"Semaphore 源码分析","translator":null,"url":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2368}]